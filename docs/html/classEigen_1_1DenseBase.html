<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NULI Avionics Flight Software: Eigen::DenseBase&lt; Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NULI Avionics Flight Software
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a href="classEigen_1_1DenseBase.html">DenseBase</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classEigen_1_1DenseBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Eigen::DenseBase&lt; Derived &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all dense matrices, vectors, and arrays.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DenseBase_8h_source.html">DenseBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Eigen::DenseBase&lt; Derived &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classEigen_1_1DenseBase__inherit__graph.png" border="0" usemap="#aEigen_1_1DenseBase_3_01Derived_01_4_inherit__map" loading="lazy" alt="Inheritance graph"/></div>
<map name="aEigen_1_1DenseBase_3_01Derived_01_4_inherit__map" id="aEigen_1_1DenseBase_3_01Derived_01_4_inherit__map">
<area shape="rect" title="Base class for all dense matrices, vectors, and arrays." alt="" coords="250,237,449,264"/>
<area shape="rect" href="classEigen_1_1ArrayBase.html" title=" " alt="" coords="497,5,739,64"/>
<area shape="poly" title=" " alt="" coords="364,222,417,149,453,109,495,74,515,62,518,67,499,78,457,113,421,152,369,225"/>
<area shape="rect" href="classEigen_1_1ArrayBase.html" title=" " alt="" coords="506,88,731,115"/>
<area shape="poly" title=" " alt="" coords="371,224,424,173,458,146,496,124,526,113,528,118,498,129,461,151,427,177,374,228"/>
<area shape="rect" href="classEigen_1_1MatrixBase.html" title=" " alt="" coords="525,139,711,197"/>
<area shape="poly" title=" " alt="" coords="409,230,524,194,525,199,410,235"/>
<area shape="rect" href="classEigen_1_1MatrixBase.html" title=" " alt="" coords="538,221,699,280"/>
<area shape="poly" title=" " alt="" coords="464,248,537,248,537,253,464,253"/>
<area shape="rect" href="classEigen_1_1MatrixBase.html" title=" " alt="" coords="550,304,686,347"/>
<area shape="poly" title=" " alt="" coords="415,266,498,289,550,304,549,309,496,295,414,271"/>
<area shape="rect" href="classEigen_1_1ArrayBase.html" title="Base class for all 1D and 2D array, and related expressions." alt="" coords="522,371,714,397"/>
<area shape="poly" title=" " alt="" coords="378,273,431,316,464,338,498,356,530,367,528,373,496,361,461,342,428,320,374,277"/>
<area shape="rect" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions." alt="" coords="550,545,686,588"/>
<area shape="poly" title=" " alt="" coords="374,274,601,543,596,547,370,278"/>
<area shape="rect" href="classEigen_1_1DenseCoeffsBase.html" title=" " alt="" coords="5,221,202,280"/>
<area shape="poly" title=" " alt="" coords="217,248,249,248,249,253,217,253"/>
<area shape="rect" href="classEigen_1_1MatrixWrapper.html" title="Expression of an array as a mathematical vector or matrix." alt="" coords="826,147,972,189"/>
<area shape="poly" title=" " alt="" coords="727,165,825,165,825,171,727,171"/>
<area shape="rect" href="classEigen_1_1SolveImpl_3_01Decomposition_00_01RhsType_00_01Dense_01_4.html" title=" " alt="" coords="787,229,1011,272"/>
<area shape="poly" title=" " alt="" coords="714,248,787,248,787,253,714,253"/>
<area shape="rect" href="classEigen_1_1ArrayWrapper.html" title=" " alt="" coords="828,329,970,372"/>
<area shape="poly" title=" " alt="" coords="730,368,828,356,828,362,730,373"/>
<area shape="rect" href="classEigen_1_1Homogeneous.html" title=" " alt="" coords="794,396,1004,455"/>
<area shape="poly" title=" " alt="" coords="663,534,721,499,786,464,812,453,814,458,789,469,724,504,666,539"/>
<area shape="rect" href="classEigen_1_1Homogeneous.html" title=" " alt="" coords="800,479,998,521"/>
<area shape="poly" title=" " alt="" coords="701,544,806,519,807,525,702,550"/>
<area shape="rect" href="classEigen_1_1Homogeneous.html" title=" " alt="" coords="823,545,975,588"/>
<area shape="poly" title=" " alt="" coords="702,564,823,564,823,569,702,569"/>
<area shape="rect" href="classEigen_1_1Homogeneous.html" title=" " alt="" coords="826,612,972,655"/>
<area shape="poly" title=" " alt="" coords="702,584,826,613,825,619,701,589"/>
<area shape="rect" href="classEigen_1_1Homogeneous.html" title=" " alt="" coords="819,679,979,721"/>
<area shape="poly" title=" " alt="" coords="665,595,722,630,788,664,820,676,818,681,786,669,720,635,662,599"/>
<area shape="rect" href="classEigen_1_1MatrixWrapper.html" title=" " alt="" coords="826,745,972,788"/>
<area shape="poly" title=" " alt="" coords="647,599,707,666,746,701,789,731,827,748,824,753,786,736,743,705,703,670,643,602"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Eigen::DenseBase&lt; Derived &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classEigen_1_1DenseBase__coll__graph.png" border="0" usemap="#aEigen_1_1DenseBase_3_01Derived_01_4_coll__map" loading="lazy" alt="Collaboration graph"/></div>
<map name="aEigen_1_1DenseBase_3_01Derived_01_4_coll__map" id="aEigen_1_1DenseBase_3_01Derived_01_4_coll__map">
<area shape="rect" title="Base class for all dense matrices, vectors, and arrays." alt="" coords="787,124,986,151"/>
<area shape="rect" href="classEigen_1_1DenseCoeffsBase.html" title=" " alt="" coords="346,67,542,125"/>
<area shape="poly" title=" " alt="" coords="558,104,787,125,786,131,557,109"/>
<area shape="rect" href="classEigen_1_1CwiseNullaryOp.html" title=" " alt="" coords="349,149,539,208"/>
<area shape="poly" title=" " alt="" coords="555,170,763,152,791,149,792,154,763,157,555,175"/>
<area shape="rect" title=" " alt="" coords="35,5,214,96"/>
<area shape="poly" title=" " alt="" coords="229,90,369,146,367,151,227,95"/>
<area shape="rect" href="classEigen_1_1internal_1_1no__assignment__operator.html" title=" " alt="" coords="50,120,199,163"/>
<area shape="poly" title=" " alt="" coords="215,149,348,165,348,170,214,154"/>
<area shape="rect" href="classEigen_1_1internal_1_1variable__if__dynamic.html" title=" " alt="" coords="5,187,244,245"/>
<area shape="poly" title=" " alt="" coords="259,198,321,191,348,188,348,193,322,196,259,203"/>
<area shape="rect" href="classEigen_1_1internal_1_1variable__if__dynamic.html" title=" " alt="" coords="9,269,240,328"/>
<area shape="poly" title=" " alt="" coords="225,261,243,255,321,227,372,206,374,211,323,232,245,260,227,266"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:CastXpr" id="r_CastXpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1CastXpr.html">CastXpr</a></td></tr>
<tr class="memitem:ConstFixedBlockXpr" id="r_ConstFixedBlockXpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a></td></tr>
<tr class="memitem:ConstFixedSegmentReturnType" id="r_ConstFixedSegmentReturnType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedSegmentReturnType.html">ConstFixedSegmentReturnType</a></td></tr>
<tr class="memitem:ConstNColsBlockXpr" id="r_ConstNColsBlockXpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1ConstNColsBlockXpr.html">ConstNColsBlockXpr</a></td></tr>
<tr class="memitem:ConstNRowsBlockXpr" id="r_ConstNRowsBlockXpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1ConstNRowsBlockXpr.html">ConstNRowsBlockXpr</a></td></tr>
<tr class="memitem:EIGEN_5FINDEXED_5FVIEW_5FMETHOD_5FTYPE" id="r_EIGEN_5FINDEXED_5FVIEW_5FMETHOD_5FTYPE"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1EIGEN__INDEXED__VIEW__METHOD__TYPE.html">EIGEN_INDEXED_VIEW_METHOD_TYPE</a></td></tr>
<tr class="memitem:FixedBlockXpr" id="r_FixedBlockXpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a></td></tr>
<tr class="memitem:FixedSegmentReturnType" id="r_FixedSegmentReturnType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a></td></tr>
<tr class="memitem:IvcColType" id="r_IvcColType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1IvcColType.html">IvcColType</a></td></tr>
<tr class="memitem:IvcRowType" id="r_IvcRowType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1IvcRowType.html">IvcRowType</a></td></tr>
<tr class="memitem:IvcType" id="r_IvcType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1IvcType.html">IvcType</a></td></tr>
<tr class="memitem:NColsBlockXpr" id="r_NColsBlockXpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a></td></tr>
<tr class="memitem:NRowsBlockXpr" id="r_NRowsBlockXpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c5061e6cfaa937b590e2d64b78a519d" id="r_a1c5061e6cfaa937b590e2d64b78a519d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a> = internal::traits&lt;Derived&gt;::RowsAtCompileTime
, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a> = internal::traits&lt;Derived&gt;::ColsAtCompileTime
, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>
, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a> = internal::traits&lt;Derived&gt;::MaxRowsAtCompileTime
, <br />
&#160;&#160;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> = internal::traits&lt;Derived&gt;::MaxColsAtCompileTime
, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a>
, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da1156955c8099c5072934b74c72654ed0">IsVectorAtCompileTime</a>
, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da4d4548a01ba37a6c2031a3c1f0a37d34">NumDimensions</a> = int(MaxSizeAtCompileTime) == 1 ? 0 : bool(IsVectorAtCompileTime) ? 1 : 2
, <br />
&#160;&#160;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">Flags</a> = internal::traits&lt;Derived&gt;::Flags
, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> = int(Flags) &amp; RowMajorBit
, <b>InnerSizeAtCompileTime</b>
, <b>InnerStrideAtCompileTime</b> = internal::inner_stride_at_compile_time&lt;Derived&gt;::ret
, <br />
&#160;&#160;<b>OuterStrideAtCompileTime</b> = internal::outer_stride_at_compile_time&lt;Derived&gt;::ret
<br />
 }</td></tr>
<tr class="memitem:a8b1e791b422807834a355925c70ad38b" id="r_a8b1e791b422807834a355925c70ad38b"><td class="memItemLeft" align="right" valign="top"><a id="a8b1e791b422807834a355925c70ad38b" name="a8b1e791b422807834a355925c70ad38b"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>IsPlainObjectBase</b> = 0
 }</td></tr>
<tr class="memitem:a4dc102b445d8fb48a28dfcd22323f649" id="r_a4dc102b445d8fb48a28dfcd22323f649"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1InnerIterator.html">Eigen::InnerIterator</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dc102b445d8fb48a28dfcd22323f649">InnerIterator</a></td></tr>
<tr class="memitem:a3b9ef013d71b5b625b50de1e42a9ef29" id="r_a3b9ef013d71b5b625b50de1e42a9ef29"><td class="memItemLeft" align="right" valign="top"><a id="a3b9ef013d71b5b625b50de1e42a9ef29" name="a3b9ef013d71b5b625b50de1e42a9ef29"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;::StorageKind&#160;</td><td class="memItemRight" valign="bottom"><b>StorageKind</b></td></tr>
<tr class="memitem:a2d1aba3f6c414715d830f760913c7e00" id="r_a2d1aba3f6c414715d830f760913c7e00"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;::StorageIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d1aba3f6c414715d830f760913c7e00">StorageIndex</a></td></tr>
<tr class="memdesc:a2d1aba3f6c414715d830f760913c7e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to store indices.  <br /></td></tr>
<tr class="memitem:a5feed465b3a8e60c47e73ecce83e39a2" id="r_a5feed465b3a8e60c47e73ecce83e39a2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a></td></tr>
<tr class="memitem:a9276182dab8236c33f1e7abf491d504d" id="r_a9276182dab8236c33f1e7abf491d504d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9276182dab8236c33f1e7abf491d504d">value_type</a></td></tr>
<tr class="memitem:a25c2ae37392d553e4a75928c5d864470" id="r_a25c2ae37392d553e4a75928c5d864470"><td class="memItemLeft" align="right" valign="top"><a id="a25c2ae37392d553e4a75928c5d864470" name="a25c2ae37392d553e4a75928c5d864470"></a>
typedef <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="memitem:a194e338172b4e261a777a1f0baaae98a" id="r_a194e338172b4e261a777a1f0baaae98a"><td class="memItemLeft" align="right" valign="top"><a id="a194e338172b4e261a777a1f0baaae98a" name="a194e338172b4e261a777a1f0baaae98a"></a>
typedef <a class="el" href="classEigen_1_1DenseCoeffsBase.html">DenseCoeffsBase</a>&lt; Derived, <a class="el" href="structEigen_1_1internal_1_1accessors__level.html">internal::accessors_level</a>&lt; Derived &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="memitem:a48f980a04d61aca7e664c301171bde5d" id="r_a48f980a04d61aca7e664c301171bde5d"><td class="memItemLeft" align="right" valign="top"><a id="a48f980a04d61aca7e664c301171bde5d" name="a48f980a04d61aca7e664c301171bde5d"></a>
typedef Base::CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><b>CoeffReturnType</b></td></tr>
<tr class="memitem:ad51e4f04d4ee2f1b03d0ff9a94092b52" id="r_ad51e4f04d4ee2f1b03d0ff9a94092b52"><td class="memItemLeft" align="right" valign="top"><a id="ad51e4f04d4ee2f1b03d0ff9a94092b52" name="ad51e4f04d4ee2f1b03d0ff9a94092b52"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1find__best__packet.html">internal::find_best_packet</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>PacketScalar</b></td></tr>
<tr class="memitem:aa301ef39d63443e9ef0b84f47350116e" id="r_aa301ef39d63443e9ef0b84f47350116e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a>|(<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a> &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> :<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa301ef39d63443e9ef0b84f47350116e">PlainMatrix</a></td></tr>
<tr class="memitem:a65328b7d6fc10a26ff6cd5801a6a44eb" id="r_a65328b7d6fc10a26ff6cd5801a6a44eb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Array.html">Array</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a>|(<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a> &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> :<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65328b7d6fc10a26ff6cd5801a6a44eb">PlainArray</a></td></tr>
<tr class="memitem:ad871c3bef0abfc3673a6963d8201be21" id="r_ad871c3bef0abfc3673a6963d8201be21"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; <a class="el" href="structEigen_1_1internal_1_1is__same.html">internal::is_same</a>&lt; typenameinternal::traits&lt; Derived &gt;::XprKind, <a class="el" href="structEigen_1_1MatrixXpr.html">MatrixXpr</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="#aa301ef39d63443e9ef0b84f47350116e">PlainMatrix</a>, <a class="el" href="#a65328b7d6fc10a26ff6cd5801a6a44eb">PlainArray</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a></td></tr>
<tr class="memdesc:ad871c3bef0abfc3673a6963d8201be21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plain matrix or array type corresponding to this expression.  <br /></td></tr>
<tr class="memitem:a3cb28fce3943b113439e17eef3c38552" id="r_a3cb28fce3943b113439e17eef3c38552"><td class="memItemLeft" align="right" valign="top"><a id="a3cb28fce3943b113439e17eef3c38552" name="a3cb28fce3943b113439e17eef3c38552"></a>
typedef <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__constant__op.html">internal::scalar_constant_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstantReturnType</b></td></tr>
<tr class="memitem:a640a374b0bda89e59b3872e9451ae8b5" id="r_a640a374b0bda89e59b3872e9451ae8b5"><td class="memItemLeft" align="right" valign="top"><a id="a640a374b0bda89e59b3872e9451ae8b5" name="a640a374b0bda89e59b3872e9451ae8b5"></a>
typedef <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; <a class="el" href="structEigen_1_1internal_1_1linspaced__op.html">internal::linspaced_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RandomAccessLinSpacedReturnType</b></td></tr>
<tr class="memitem:abf79da5aee53380388f9bc44fa200d25" id="r_abf79da5aee53380388f9bc44fa200d25"><td class="memItemLeft" align="right" valign="top"><a id="abf79da5aee53380388f9bc44fa200d25" name="abf79da5aee53380388f9bc44fa200d25"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> &gt;::Real, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EigenvaluesReturnType</b></td></tr>
<tr class="memitem:a958c42582382e4bec8f58d380e277e45" id="r_a958c42582382e4bec8f58d380e277e45"><td class="memItemLeft" align="right" valign="top"><a id="a958c42582382e4bec8f58d380e277e45" name="a958c42582382e4bec8f58d380e277e45"></a>
typedef <a class="el" href="classEigen_1_1Transpose.html">Transpose</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TransposeReturnType</b></td></tr>
<tr class="memitem:a3970401c40e9adfe42618bca36d2768e" id="r_a3970401c40e9adfe42618bca36d2768e"><td class="memItemLeft" align="right" valign="top"><a id="a3970401c40e9adfe42618bca36d2768e" name="a3970401c40e9adfe42618bca36d2768e"></a>
typedef <a class="el" href="classEigen_1_1Transpose.html">Transpose</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstTransposeReturnType</b></td></tr>
<tr class="memitem:a70cf4c2bc191461b218771434807c7c5" id="r_a70cf4c2bc191461b218771434807c7c5"><td class="memItemLeft" align="right" valign="top"><a id="a70cf4c2bc191461b218771434807c7c5" name="a70cf4c2bc191461b218771434807c7c5"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1add__const__on__value__type.html">internal::add_const_on_value_type</a>&lt; typenameinternal::eval&lt; Derived &gt;::type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>EvalReturnType</b></td></tr>
<tr class="memitem:a45e67608607905de9f335661fae4c1a2" id="r_a45e67608607905de9f335661fae4c1a2"><td class="memItemLeft" align="right" valign="top"><a id="a45e67608607905de9f335661fae4c1a2" name="a45e67608607905de9f335661fae4c1a2"></a>
typedef <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; Derived, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a961c62410157b64033839488f4d7f7e4">Horizontal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RowwiseReturnType</b></td></tr>
<tr class="memitem:af3f26a9a37c53e444cba128a175a8222" id="r_af3f26a9a37c53e444cba128a175a8222"><td class="memItemLeft" align="right" valign="top"><a id="af3f26a9a37c53e444cba128a175a8222" name="af3f26a9a37c53e444cba128a175a8222"></a>
typedef const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; const Derived, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a961c62410157b64033839488f4d7f7e4">Horizontal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstRowwiseReturnType</b></td></tr>
<tr class="memitem:a5d3c60a2c900d52930a2630fff2d7847" id="r_a5d3c60a2c900d52930a2630fff2d7847"><td class="memItemLeft" align="right" valign="top"><a id="a5d3c60a2c900d52930a2630fff2d7847" name="a5d3c60a2c900d52930a2630fff2d7847"></a>
typedef <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; Derived, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ColwiseReturnType</b></td></tr>
<tr class="memitem:a86588301ac5c062a63c68dff9349ccab" id="r_a86588301ac5c062a63c68dff9349ccab"><td class="memItemLeft" align="right" valign="top"><a id="a86588301ac5c062a63c68dff9349ccab" name="a86588301ac5c062a63c68dff9349ccab"></a>
typedef const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; const Derived, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstColwiseReturnType</b></td></tr>
<tr class="memitem:a050c96f67131df5e47e00c29446fb50d" id="r_a050c96f67131df5e47e00c29446fb50d"><td class="memItemLeft" align="right" valign="top"><a id="a050c96f67131df5e47e00c29446fb50d" name="a050c96f67131df5e47e00c29446fb50d"></a>
typedef <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__random__op.html">internal::scalar_random_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RandomReturnType</b></td></tr>
<tr class="memitem:a7428b2b404ef14d402b76ee87b941442" id="r_a7428b2b404ef14d402b76ee87b941442"><td class="memItemLeft" align="right" valign="top"><a id="a7428b2b404ef14d402b76ee87b941442" name="a7428b2b404ef14d402b76ee87b941442"></a>
typedef <a class="el" href="classEigen_1_1Reverse.html">Reverse</a>&lt; Derived, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a04fefd61992e941d509a57bc44c59794">BothDirections</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseReturnType</b></td></tr>
<tr class="memitem:af49b9a56cfe2d2dc02e18dc073bcfbfa" id="r_af49b9a56cfe2d2dc02e18dc073bcfbfa"><td class="memItemLeft" align="right" valign="top"><a id="af49b9a56cfe2d2dc02e18dc073bcfbfa" name="af49b9a56cfe2d2dc02e18dc073bcfbfa"></a>
typedef const <a class="el" href="classEigen_1_1Reverse.html">Reverse</a>&lt; const Derived, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a04fefd61992e941d509a57bc44c59794">BothDirections</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstReverseReturnType</b></td></tr>
<tr class="memitem:aa98b4f5b257a23636b7187243089a74c" id="r_aa98b4f5b257a23636b7187243089a74c"><td class="memItemLeft" align="right" valign="top"><a id="aa98b4f5b257a23636b7187243089a74c" name="aa98b4f5b257a23636b7187243089a74c"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt;(<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">Flags</a> &amp;<a class="el" href="group__flags.html#gabf1e9d0516a933445a4c307ad8f14915">DirectAccessBit</a>)==<a class="el" href="group__flags.html#gabf1e9d0516a933445a4c307ad8f14915">DirectAccessBit</a>, <a class="el" href="classEigen_1_1internal_1_1pointer__based__stl__iterator.html">internal::pointer_based_stl_iterator</a>&lt; Derived &gt;, <a class="el" href="classEigen_1_1internal_1_1generic__randaccess__stl__iterator.html">internal::generic_randaccess_stl_iterator</a>&lt; Derived &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_type</b></td></tr>
<tr class="memitem:a95620fcdf79ad3b416502c476873ffb2" id="r_a95620fcdf79ad3b416502c476873ffb2"><td class="memItemLeft" align="right" valign="top"><a id="a95620fcdf79ad3b416502c476873ffb2" name="a95620fcdf79ad3b416502c476873ffb2"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt;(<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">Flags</a> &amp;<a class="el" href="group__flags.html#gabf1e9d0516a933445a4c307ad8f14915">DirectAccessBit</a>)==<a class="el" href="group__flags.html#gabf1e9d0516a933445a4c307ad8f14915">DirectAccessBit</a>, <a class="el" href="classEigen_1_1internal_1_1pointer__based__stl__iterator.html">internal::pointer_based_stl_iterator</a>&lt; constDerived &gt;, <a class="el" href="classEigen_1_1internal_1_1generic__randaccess__stl__iterator.html">internal::generic_randaccess_stl_iterator</a>&lt; constDerived &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator_type</b></td></tr>
<tr class="memitem:aa4c433fcd0538c55cf16b792c1fff3cf" id="r_aa4c433fcd0538c55cf16b792c1fff3cf"><td class="memItemLeft" align="right" valign="top"><a id="aa4c433fcd0538c55cf16b792c1fff3cf" name="aa4c433fcd0538c55cf16b792c1fff3cf"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da1156955c8099c5072934b74c72654ed0">IsVectorAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1true__type.html">iterator_type</a>, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="memitem:a4c758fa9f01cd53c456afafa13da03bd" id="r_a4c758fa9f01cd53c456afafa13da03bd"><td class="memItemLeft" align="right" valign="top"><a id="a4c758fa9f01cd53c456afafa13da03bd" name="a4c758fa9f01cd53c456afafa13da03bd"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da1156955c8099c5072934b74c72654ed0">IsVectorAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1true__type.html">const_iterator_type</a>, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="memitem:aab45c8c10d4d1b1bd35a9f096cbc98c3" id="r_aab45c8c10d4d1b1bd35a9f096cbc98c3"><td class="memItemLeft" align="right" valign="top"><a id="aab45c8c10d4d1b1bd35a9f096cbc98c3" name="aab45c8c10d4d1b1bd35a9f096cbc98c3"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::IsComplex, constCwiseUnaryOp&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__conjugate__op.html">internal::scalar_conjugate_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, constDerived &gt;, constDerived &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>ConjugateReturnType</b></td></tr>
<tr class="memitem:a7965f1c6f997fd64225dd954e875e454" id="r_a7965f1c6f997fd64225dd954e875e454"><td class="memItemLeft" align="right" valign="top"><a id="a7965f1c6f997fd64225dd954e875e454" name="a7965f1c6f997fd64225dd954e875e454"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::IsComplex, constCwiseUnaryOp&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__real__op.html">internal::scalar_real_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, constDerived &gt;, constDerived &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>RealReturnType</b></td></tr>
<tr class="memitem:a0d873ad3e59052efc9cb3a670747b017" id="r_a0d873ad3e59052efc9cb3a670747b017"><td class="memItemLeft" align="right" valign="top"><a id="a0d873ad3e59052efc9cb3a670747b017" name="a0d873ad3e59052efc9cb3a670747b017"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::IsComplex, <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__real__ref__op.html">internal::scalar_real_ref_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, Derived &gt;, Derived &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>NonConstRealReturnType</b></td></tr>
<tr class="memitem:ab0cbb35c23e09831a8ea63a2ec5faa1b" id="r_ab0cbb35c23e09831a8ea63a2ec5faa1b"><td class="memItemLeft" align="right" valign="top"><a id="ab0cbb35c23e09831a8ea63a2ec5faa1b" name="ab0cbb35c23e09831a8ea63a2ec5faa1b"></a>
typedef <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__imag__op.html">internal::scalar_imag_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ImagReturnType</b></td></tr>
<tr class="memitem:acf7bcbcc9aee82c1ed1770e47d9f81af" id="r_acf7bcbcc9aee82c1ed1770e47d9f81af"><td class="memItemLeft" align="right" valign="top"><a id="acf7bcbcc9aee82c1ed1770e47d9f81af" name="acf7bcbcc9aee82c1ed1770e47d9f81af"></a>
typedef <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__imag__ref__op.html">internal::scalar_imag_ref_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NonConstImagReturnType</b></td></tr>
<tr class="memitem:ad40d4dee93350cad337e58f85956c22f" id="r_ad40d4dee93350cad337e58f85956c22f"><td class="memItemLeft" align="right" valign="top"><a id="ad40d4dee93350cad337e58f85956c22f" name="ad40d4dee93350cad337e58f85956c22f"></a>
typedef <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt; <a class="el" href="structEigen_1_1internal_1_1scalar__opposite__op.html">internal::scalar_opposite_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NegativeReturnType</b></td></tr>
<tr class="memitem:a125b308bb50ba123174d2399f897d6a0" id="r_a125b308bb50ba123174d2399f897d6a0"><td class="memItemLeft" align="right" valign="top"><a id="a125b308bb50ba123174d2399f897d6a0" name="a125b308bb50ba123174d2399f897d6a0"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, 1, !<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ColXpr</b></td></tr>
<tr class="memitem:a54144b270cb8b76de5806f4f1709ebe2" id="r_a54144b270cb8b76de5806f4f1709ebe2"><td class="memItemLeft" align="right" valign="top"><a id="a54144b270cb8b76de5806f4f1709ebe2" name="a54144b270cb8b76de5806f4f1709ebe2"></a>
typedef const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, 1, !<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstColXpr</b></td></tr>
<tr class="memitem:a0ba4f7d1796d72c199732df4ac22ac2e" id="r_a0ba4f7d1796d72c199732df4ac22ac2e"><td class="memItemLeft" align="right" valign="top"><a id="a0ba4f7d1796d72c199732df4ac22ac2e" name="a0ba4f7d1796d72c199732df4ac22ac2e"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, 1, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RowXpr</b></td></tr>
<tr class="memitem:a94ec931b9d7c9154d8799d5084b419c3" id="r_a94ec931b9d7c9154d8799d5084b419c3"><td class="memItemLeft" align="right" valign="top"><a id="a94ec931b9d7c9154d8799d5084b419c3" name="a94ec931b9d7c9154d8799d5084b419c3"></a>
typedef const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, 1, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstRowXpr</b></td></tr>
<tr class="memitem:a930a151aadc2ff8538f9ca93ee8eb3ba" id="r_a930a151aadc2ff8538f9ca93ee8eb3ba"><td class="memItemLeft" align="right" valign="top"><a id="a930a151aadc2ff8538f9ca93ee8eb3ba" name="a930a151aadc2ff8538f9ca93ee8eb3ba"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, !<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ColsBlockXpr</b></td></tr>
<tr class="memitem:a4e0d5404b927fa8e9e6d55fb3bf1ca2d" id="r_a4e0d5404b927fa8e9e6d55fb3bf1ca2d"><td class="memItemLeft" align="right" valign="top"><a id="a4e0d5404b927fa8e9e6d55fb3bf1ca2d" name="a4e0d5404b927fa8e9e6d55fb3bf1ca2d"></a>
typedef const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, !<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstColsBlockXpr</b></td></tr>
<tr class="memitem:ad79e2820eb2d754fd40eff7f0e3609e3" id="r_ad79e2820eb2d754fd40eff7f0e3609e3"><td class="memItemLeft" align="right" valign="top"><a id="ad79e2820eb2d754fd40eff7f0e3609e3" name="ad79e2820eb2d754fd40eff7f0e3609e3"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RowsBlockXpr</b></td></tr>
<tr class="memitem:aa7758acb8661ab4b3e7be108ab5f8380" id="r_aa7758acb8661ab4b3e7be108ab5f8380"><td class="memItemLeft" align="right" valign="top"><a id="aa7758acb8661ab4b3e7be108ab5f8380" name="aa7758acb8661ab4b3e7be108ab5f8380"></a>
typedef const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstRowsBlockXpr</b></td></tr>
<tr class="memitem:a73a0ff2ad5a52e67ea44242f9beb122a" id="r_a73a0ff2ad5a52e67ea44242f9beb122a"><td class="memItemLeft" align="right" valign="top"><a id="a73a0ff2ad5a52e67ea44242f9beb122a" name="a73a0ff2ad5a52e67ea44242f9beb122a"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlockXpr</b></td></tr>
<tr class="memitem:a358d1654d234e4f7b8fc7d289c4f0597" id="r_a358d1654d234e4f7b8fc7d289c4f0597"><td class="memItemLeft" align="right" valign="top"><a id="a358d1654d234e4f7b8fc7d289c4f0597" name="a358d1654d234e4f7b8fc7d289c4f0597"></a>
typedef const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstBlockXpr</b></td></tr>
<tr class="memitem:a42519f2e9d1a0408ae119050971b4c0f" id="r_a42519f2e9d1a0408ae119050971b4c0f"><td class="memItemLeft" align="right" valign="top"><a id="a42519f2e9d1a0408ae119050971b4c0f" name="a42519f2e9d1a0408ae119050971b4c0f"></a>
typedef <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SegmentReturnType</b></td></tr>
<tr class="memitem:a44f2b8d571ed158bb8b8cec0314090c3" id="r_a44f2b8d571ed158bb8b8cec0314090c3"><td class="memItemLeft" align="right" valign="top"><a id="a44f2b8d571ed158bb8b8cec0314090c3" name="a44f2b8d571ed158bb8b8cec0314090c3"></a>
typedef const <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSegmentReturnType</b></td></tr>
<tr class="memitem:a5699fe786bef4441ac2ceb22af1772fd" id="r_a5699fe786bef4441ac2ceb22af1772fd"><td class="memItemLeft" align="right" valign="top"><a id="a5699fe786bef4441ac2ceb22af1772fd" name="a5699fe786bef4441ac2ceb22af1772fd"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>?1:<a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>?Dynamic:1, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InnerVectorReturnType</b></td></tr>
<tr class="memitem:a02cce2f49de1d2f8596fd2f93b0658ec" id="r_a02cce2f49de1d2f8596fd2f93b0658ec"><td class="memItemLeft" align="right" valign="top"><a id="a02cce2f49de1d2f8596fd2f93b0658ec" name="a02cce2f49de1d2f8596fd2f93b0658ec"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>?1:<a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>?Dynamic:1, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstInnerVectorReturnType</b></td></tr>
<tr class="memitem:a13d0c5016134a9c01cd41ad6ffafccd7" id="r_a13d0c5016134a9c01cd41ad6ffafccd7"><td class="memItemLeft" align="right" valign="top"><a id="a13d0c5016134a9c01cd41ad6ffafccd7" name="a13d0c5016134a9c01cd41ad6ffafccd7"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InnerVectorsReturnType</b></td></tr>
<tr class="memitem:a7cc767902d73abb61cb9ac2c3232c8b1" id="r_a7cc767902d73abb61cb9ac2c3232c8b1"><td class="memItemLeft" align="right" valign="top"><a id="a7cc767902d73abb61cb9ac2c3232c8b1" name="a7cc767902d73abb61cb9ac2c3232c8b1"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstInnerVectorsReturnType</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a64ca9fffefedd184e634f8cf087f6588" id="r_a64ca9fffefedd184e634f8cf087f6588"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ca9fffefedd184e634f8cf087f6588">nonZeros</a> () const</td></tr>
<tr class="memitem:a1e002168ce504d56d923e54463ae6553" id="r_a1e002168ce504d56d923e54463ae6553"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e002168ce504d56d923e54463ae6553">outerSize</a> () const</td></tr>
<tr class="memitem:a02f27b90d1665656238d55e5d64e5d6f" id="r_a02f27b90d1665656238d55e5d64e5d6f"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02f27b90d1665656238d55e5d64e5d6f">innerSize</a> () const</td></tr>
<tr class="memitem:a13027a493a68a13496610caf3d81bd3e" id="r_a13027a493a68a13496610caf3d81bd3e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13027a493a68a13496610caf3d81bd3e">resize</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> newSize)</td></tr>
<tr class="memitem:aef40c2ee48a85a799270c8258cc12b76" id="r_aef40c2ee48a85a799270c8258cc12b76"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef40c2ee48a85a799270c8258cc12b76">resize</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols)</td></tr>
<tr class="memitem:a581a7a353bd007b5352f11688e3bc5fa" id="r_a581a7a353bd007b5352f11688e3bc5fa"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a581a7a353bd007b5352f11688e3bc5fa template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a581a7a353bd007b5352f11688e3bc5fa">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:aae79d5d0d95e60bf2e64d0dc3dfd66a4" id="r_aae79d5d0d95e60bf2e64d0dc3dfd66a4"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae79d5d0d95e60bf2e64d0dc3dfd66a4">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a> &amp;other)</td></tr>
<tr class="memitem:a6462697d5a6fa3104f5f1213fdf9ff12" id="r_a6462697d5a6fa3104f5f1213fdf9ff12"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a6462697d5a6fa3104f5f1213fdf9ff12 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6462697d5a6fa3104f5f1213fdf9ff12">operator=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a6462697d5a6fa3104f5f1213fdf9ff12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the generic expression <em class="arg">other</em> into *this.  <br /></td></tr>
<tr class="memitem:a8fdd498a76ab5e136e3c55b1412cd8c4" id="r_a8fdd498a76ab5e136e3c55b1412cd8c4"><td class="memTemplParams" colspan="2"><a id="a8fdd498a76ab5e136e3c55b1412cd8c4" name="a8fdd498a76ab5e136e3c55b1412cd8c4"></a>
template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a8fdd498a76ab5e136e3c55b1412cd8c4 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a5ce384b60166efd51356eb738f534144" id="r_a5ce384b60166efd51356eb738f534144"><td class="memTemplParams" colspan="2"><a id="a5ce384b60166efd51356eb738f534144" name="a5ce384b60166efd51356eb738f534144"></a>
template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a5ce384b60166efd51356eb738f534144 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a4f3c8f1d7d7fd061eb61b97c85b98e4b" id="r_a4f3c8f1d7d7fd061eb61b97c85b98e4b"><td class="memTemplParams" colspan="2"><a id="a4f3c8f1d7d7fd061eb61b97c85b98e4b" name="a4f3c8f1d7d7fd061eb61b97c85b98e4b"></a>
template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a4f3c8f1d7d7fd061eb61b97c85b98e4b template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classEigen_1_1ReturnByValue.html">ReturnByValue</a>&lt; OtherDerived &gt; &amp;func)</td></tr>
<tr class="memitem:aa394a9eeea28fee3c4624a5f9c666c7d" id="r_aa394a9eeea28fee3c4624a5f9c666c7d"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:aa394a9eeea28fee3c4624a5f9c666c7d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEPRECATED EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa394a9eeea28fee3c4624a5f9c666c7d">lazyAssign</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:ae55fbfa5630cabf2a9cba1248581bc66" id="r_ae55fbfa5630cabf2a9cba1248581bc66"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae55fbfa5630cabf2a9cba1248581bc66">operator&lt;&lt;</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;s)</td></tr>
<tr class="memitem:ae2db4b4596edd1bf7e1c43ac2d306047" id="r_ae2db4b4596edd1bf7e1c43ac2d306047"><td class="memTemplParams" colspan="2">template&lt;unsigned int Added, unsigned int Removed&gt; </td></tr>
<tr class="memitem:ae2db4b4596edd1bf7e1c43ac2d306047 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEPRECATED const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2db4b4596edd1bf7e1c43ac2d306047">flagged</a> () const</td></tr>
<tr class="memitem:ad0054eb99270d11e4b2f57ade70f0c1d" id="r_ad0054eb99270d11e4b2f57ade70f0c1d"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:ad0054eb99270d11e4b2f57ade70f0c1d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0054eb99270d11e4b2f57ade70f0c1d">operator&lt;&lt;</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:acdada00d813939c0c9e90db5c01585c8" id="r_acdada00d813939c0c9e90db5c01585c8"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Transpose.html">TransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdada00d813939c0c9e90db5c01585c8">transpose</a> ()</td></tr>
<tr class="memitem:aeedbef96d04a73342f6f62ec1a1c46e3" id="r_aeedbef96d04a73342f6f62ec1a1c46e3"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Transpose.html">ConstTransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeedbef96d04a73342f6f62ec1a1c46e3">transpose</a> () const</td></tr>
<tr class="memitem:a2bf1856f4ff79f0db0e6d416a2edfb0f" id="r_a2bf1856f4ff79f0db0e6d416a2edfb0f"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bf1856f4ff79f0db0e6d416a2edfb0f">transposeInPlace</a> ()</td></tr>
<tr class="memitem:a4f5eb49e80db57f79a8353ecdf811418" id="r_a4f5eb49e80db57f79a8353ecdf811418"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f5eb49e80db57f79a8353ecdf811418">fill</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a>)</td></tr>
<tr class="memitem:a19b2bc788277e9ab3f967a8857e290ae" id="r_a19b2bc788277e9ab3f967a8857e290ae"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19b2bc788277e9ab3f967a8857e290ae">setConstant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a>)</td></tr>
<tr class="memitem:a17a69cfd1b44b64f26b1a0f00666a871" id="r_a17a69cfd1b44b64f26b1a0f00666a871"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17a69cfd1b44b64f26b1a0f00666a871">setLinSpaced</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:a17a69cfd1b44b64f26b1a0f00666a871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <br /></td></tr>
<tr class="memitem:a99dd31774d69545aba5d4f598cd27c4b" id="r_a99dd31774d69545aba5d4f598cd27c4b"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99dd31774d69545aba5d4f598cd27c4b">setLinSpaced</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:a99dd31774d69545aba5d4f598cd27c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <br /></td></tr>
<tr class="memitem:ac74411ddeea2545bf20baf14613be47e" id="r_ac74411ddeea2545bf20baf14613be47e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac74411ddeea2545bf20baf14613be47e">setZero</a> ()</td></tr>
<tr class="memitem:ad18970fd7d9f9c3d8db9d05fa8652a25" id="r_ad18970fd7d9f9c3d8db9d05fa8652a25"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad18970fd7d9f9c3d8db9d05fa8652a25">setOnes</a> ()</td></tr>
<tr class="memitem:a39046dff78acbcb389ad0b018e587c8e" id="r_a39046dff78acbcb389ad0b018e587c8e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39046dff78acbcb389ad0b018e587c8e">setRandom</a> ()</td></tr>
<tr class="memitem:af3793521d788a946cb9c5f4f92bab4d3" id="r_af3793521d788a946cb9c5f4f92bab4d3"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:af3793521d788a946cb9c5f4f92bab4d3 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3793521d788a946cb9c5f4f92bab4d3">isApprox</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:acc982903f94ed372fafa901e6822ae8d" id="r_acc982903f94ed372fafa901e6822ae8d"><td class="memItemLeft" align="right" valign="top"><a id="acc982903f94ed372fafa901e6822ae8d" name="acc982903f94ed372fafa901e6822ae8d"></a>
EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><b>isMuchSmallerThan</b> (const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;other, const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a800a25f323fc4222c822be5fdad729ac" id="r_a800a25f323fc4222c822be5fdad729ac"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a800a25f323fc4222c822be5fdad729ac template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a800a25f323fc4222c822be5fdad729ac">isMuchSmallerThan</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:aafb86c9868d3d9076e01e4fc54c93e81" id="r_aafb86c9868d3d9076e01e4fc54c93e81"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafb86c9868d3d9076e01e4fc54c93e81">isApproxToConstant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a>, const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:aba0e5df04cf80214d8298aa8dd41acbd" id="r_aba0e5df04cf80214d8298aa8dd41acbd"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba0e5df04cf80214d8298aa8dd41acbd">isConstant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a>, const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:aad9b1b1368b249e0e0f14b7f2960fb58" id="r_aad9b1b1368b249e0e0f14b7f2960fb58"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad9b1b1368b249e0e0f14b7f2960fb58">isZero</a> (const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:a91fb1c80e1fd4970a16fd509764225d7" id="r_a91fb1c80e1fd4970a16fd509764225d7"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91fb1c80e1fd4970a16fd509764225d7">isOnes</a> (const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="memitem:ab13d158c900560d3e1b25d85d2d33dd6" id="r_ab13d158c900560d3e1b25d85d2d33dd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab13d158c900560d3e1b25d85d2d33dd6">hasNaN</a> () const</td></tr>
<tr class="memitem:af1e669fd3aaae50a4870dc1b8f3b8884" id="r_af1e669fd3aaae50a4870dc1b8f3b8884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1e669fd3aaae50a4870dc1b8f3b8884">allFinite</a> () const</td></tr>
<tr class="memitem:a76686ac27572dc5f07b068a9c43aa1b9" id="r_a76686ac27572dc5f07b068a9c43aa1b9"><td class="memItemLeft" align="right" valign="top"><a id="a76686ac27572dc5f07b068a9c43aa1b9" name="a76686ac27572dc5f07b068a9c43aa1b9"></a>
EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;other)</td></tr>
<tr class="memitem:a7d10c42cfb8809d06310970ae7ae4331" id="r_a7d10c42cfb8809d06310970ae7ae4331"><td class="memItemLeft" align="right" valign="top"><a id="a7d10c42cfb8809d06310970ae7ae4331" name="a7d10c42cfb8809d06310970ae7ae4331"></a>
EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;other)</td></tr>
<tr class="memitem:a5df64c66228ba75bbc66db2584185527" id="r_a5df64c66228ba75bbc66db2584185527"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EvalReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df64c66228ba75bbc66db2584185527">eval</a> () const</td></tr>
<tr class="memitem:a40aa938e7e7fecafb3178ef37dc977ec" id="r_a40aa938e7e7fecafb3178ef37dc977ec"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a40aa938e7e7fecafb3178ef37dc977ec template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40aa938e7e7fecafb3178ef37dc977ec">swap</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:a23524b632b0dab3e3fa52378ef863f77" id="r_a23524b632b0dab3e3fa52378ef863f77"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:a23524b632b0dab3e3fa52378ef863f77 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23524b632b0dab3e3fa52378ef863f77">swap</a> (<a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:aa031d4cb63530f9e0a1627fd0408fdcb" id="r_aa031d4cb63530f9e0a1627fd0408fdcb"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa031d4cb63530f9e0a1627fd0408fdcb">nestByValue</a> () const</td></tr>
<tr class="memitem:a4eff62495b6e5b11d183b4b0efd00910" id="r_a4eff62495b6e5b11d183b4b0efd00910"><td class="memItemLeft" align="right" valign="top"><a id="a4eff62495b6e5b11d183b4b0efd00910" name="a4eff62495b6e5b11d183b4b0efd00910"></a>
EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>forceAlignedAccess</b> () const</td></tr>
<tr class="memitem:a851f8d7eb188e4efa2a5e0670e60690f" id="r_a851f8d7eb188e4efa2a5e0670e60690f"><td class="memItemLeft" align="right" valign="top"><a id="a851f8d7eb188e4efa2a5e0670e60690f" name="a851f8d7eb188e4efa2a5e0670e60690f"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>forceAlignedAccess</b> ()</td></tr>
<tr class="memitem:a2e7a2cee80b21a9af02b1c42bfc0e5da" id="r_a2e7a2cee80b21a9af02b1c42bfc0e5da"><td class="memTemplParams" colspan="2"><a id="a2e7a2cee80b21a9af02b1c42bfc0e5da" name="a2e7a2cee80b21a9af02b1c42bfc0e5da"></a>
template&lt;bool Enable&gt; </td></tr>
<tr class="memitem:a2e7a2cee80b21a9af02b1c42bfc0e5da template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Enable, <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt;, Derived &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>forceAlignedAccessIf</b> () const</td></tr>
<tr class="memitem:a6c3d1bbd3227f1451c691c48d07bc2f0" id="r_a6c3d1bbd3227f1451c691c48d07bc2f0"><td class="memTemplParams" colspan="2"><a id="a6c3d1bbd3227f1451c691c48d07bc2f0" name="a6c3d1bbd3227f1451c691c48d07bc2f0"></a>
template&lt;bool Enable&gt; </td></tr>
<tr class="memitem:a6c3d1bbd3227f1451c691c48d07bc2f0 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Enable, <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt;, Derived &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>forceAlignedAccessIf</b> ()</td></tr>
<tr class="memitem:ac7b6e2d5e05f37b6cd3f213d28fdac24" id="r_ac7b6e2d5e05f37b6cd3f213d28fdac24"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7b6e2d5e05f37b6cd3f213d28fdac24">sum</a> () const</td></tr>
<tr class="memitem:acd8b96239d3cd5e5bd4f207e86fafa11" id="r_acd8b96239d3cd5e5bd4f207e86fafa11"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd8b96239d3cd5e5bd4f207e86fafa11">mean</a> () const</td></tr>
<tr class="memitem:aec2e28e262377862835ba80932291997" id="r_aec2e28e262377862835ba80932291997"><td class="memItemLeft" align="right" valign="top"><a id="aec2e28e262377862835ba80932291997" name="aec2e28e262377862835ba80932291997"></a>
EIGEN_DEVICE_FUNC <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>trace</b> () const</td></tr>
<tr class="memitem:aba82045810e94956b893911c732fa4a8" id="r_aba82045810e94956b893911c732fa4a8"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba82045810e94956b893911c732fa4a8">prod</a> () const</td></tr>
<tr class="memitem:a62d1a22ba775a392784a365265186067" id="r_a62d1a22ba775a392784a365265186067"><td class="memTemplParams" colspan="2"><a id="a62d1a22ba775a392784a365265186067" name="a62d1a22ba775a392784a365265186067"></a>
template&lt;int NaNPropagation&gt; </td></tr>
<tr class="memitem:a62d1a22ba775a392784a365265186067 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>minCoeff</b> () const</td></tr>
<tr class="memitem:a90f31c27f2a2df8ee729fd081821b9e7" id="r_a90f31c27f2a2df8ee729fd081821b9e7"><td class="memTemplParams" colspan="2"><a id="a90f31c27f2a2df8ee729fd081821b9e7" name="a90f31c27f2a2df8ee729fd081821b9e7"></a>
template&lt;int NaNPropagation&gt; </td></tr>
<tr class="memitem:a90f31c27f2a2df8ee729fd081821b9e7 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>maxCoeff</b> () const</td></tr>
<tr class="memitem:a18cf660f4194114bed38cd40bbe74c1b" id="r_a18cf660f4194114bed38cd40bbe74c1b"><td class="memItemLeft" align="right" valign="top"><a id="a18cf660f4194114bed38cd40bbe74c1b" name="a18cf660f4194114bed38cd40bbe74c1b"></a>
EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>minCoeff</b> () const</td></tr>
<tr class="memitem:ad0dc4d7ea0f2689c30098d090c7ec5d8" id="r_ad0dc4d7ea0f2689c30098d090c7ec5d8"><td class="memItemLeft" align="right" valign="top"><a id="ad0dc4d7ea0f2689c30098d090c7ec5d8" name="ad0dc4d7ea0f2689c30098d090c7ec5d8"></a>
EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>maxCoeff</b> () const</td></tr>
<tr class="memitem:a4ca170ba37a8def95cca1965aecce1d1" id="r_a4ca170ba37a8def95cca1965aecce1d1"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType&gt; </td></tr>
<tr class="memitem:a4ca170ba37a8def95cca1965aecce1d1 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ca170ba37a8def95cca1965aecce1d1">minCoeff</a> (IndexType *<a class="el" href="#ac4c69272b7de4fae22f5f13968fb6703">row</a>, IndexType *<a class="el" href="#ad0c05525967c16738c2cd2285b38a91f">col</a>) const</td></tr>
<tr class="memitem:af3f427712ee1abba1a2fb9c1b15793d6" id="r_af3f427712ee1abba1a2fb9c1b15793d6"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType&gt; </td></tr>
<tr class="memitem:af3f427712ee1abba1a2fb9c1b15793d6 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3f427712ee1abba1a2fb9c1b15793d6">maxCoeff</a> (IndexType *<a class="el" href="#ac4c69272b7de4fae22f5f13968fb6703">row</a>, IndexType *<a class="el" href="#ad0c05525967c16738c2cd2285b38a91f">col</a>) const</td></tr>
<tr class="memitem:a5ac4a70f0e577e12fb5b41645b5d98ac" id="r_a5ac4a70f0e577e12fb5b41645b5d98ac"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType&gt; </td></tr>
<tr class="memitem:a5ac4a70f0e577e12fb5b41645b5d98ac template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ac4a70f0e577e12fb5b41645b5d98ac">minCoeff</a> (IndexType *index) const</td></tr>
<tr class="memitem:a06e7d0844fbc20829bd37f2924bd2252" id="r_a06e7d0844fbc20829bd37f2924bd2252"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation, typename IndexType&gt; </td></tr>
<tr class="memitem:a06e7d0844fbc20829bd37f2924bd2252 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06e7d0844fbc20829bd37f2924bd2252">maxCoeff</a> (IndexType *index) const</td></tr>
<tr class="memitem:a05044a037125e705d87bd28f678b914c" id="r_a05044a037125e705d87bd28f678b914c"><td class="memTemplParams" colspan="2"><a id="a05044a037125e705d87bd28f678b914c" name="a05044a037125e705d87bd28f678b914c"></a>
template&lt;typename IndexType&gt; </td></tr>
<tr class="memitem:a05044a037125e705d87bd28f678b914c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>minCoeff</b> (IndexType *<a class="el" href="#ac4c69272b7de4fae22f5f13968fb6703">row</a>, IndexType *<a class="el" href="#ad0c05525967c16738c2cd2285b38a91f">col</a>) const</td></tr>
<tr class="memitem:ab8318ab23b3d421b809fef0cb24f69e3" id="r_ab8318ab23b3d421b809fef0cb24f69e3"><td class="memTemplParams" colspan="2"><a id="ab8318ab23b3d421b809fef0cb24f69e3" name="ab8318ab23b3d421b809fef0cb24f69e3"></a>
template&lt;typename IndexType&gt; </td></tr>
<tr class="memitem:ab8318ab23b3d421b809fef0cb24f69e3 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>maxCoeff</b> (IndexType *<a class="el" href="#ac4c69272b7de4fae22f5f13968fb6703">row</a>, IndexType *<a class="el" href="#ad0c05525967c16738c2cd2285b38a91f">col</a>) const</td></tr>
<tr class="memitem:a7d6ebd550eaaee24fed7880c39ae3f35" id="r_a7d6ebd550eaaee24fed7880c39ae3f35"><td class="memTemplParams" colspan="2"><a id="a7d6ebd550eaaee24fed7880c39ae3f35" name="a7d6ebd550eaaee24fed7880c39ae3f35"></a>
template&lt;typename IndexType&gt; </td></tr>
<tr class="memitem:a7d6ebd550eaaee24fed7880c39ae3f35 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>minCoeff</b> (IndexType *index) const</td></tr>
<tr class="memitem:ac7f03010f4e0891c90cdcfe123f45223" id="r_ac7f03010f4e0891c90cdcfe123f45223"><td class="memTemplParams" colspan="2"><a id="ac7f03010f4e0891c90cdcfe123f45223" name="ac7f03010f4e0891c90cdcfe123f45223"></a>
template&lt;typename IndexType&gt; </td></tr>
<tr class="memitem:ac7f03010f4e0891c90cdcfe123f45223 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>maxCoeff</b> (IndexType *index) const</td></tr>
<tr class="memitem:abeb8cc034b4c9c2e36a15590d24a461c" id="r_abeb8cc034b4c9c2e36a15590d24a461c"><td class="memTemplParams" colspan="2"><a id="abeb8cc034b4c9c2e36a15590d24a461c" name="abeb8cc034b4c9c2e36a15590d24a461c"></a>
template&lt;typename BinaryOp&gt; </td></tr>
<tr class="memitem:abeb8cc034b4c9c2e36a15590d24a461c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>redux</b> (const BinaryOp &amp;func) const</td></tr>
<tr class="memitem:a7f73df3954a09c7ab0dca208b6b23ddd" id="r_a7f73df3954a09c7ab0dca208b6b23ddd"><td class="memTemplParams" colspan="2">template&lt;typename Visitor&gt; </td></tr>
<tr class="memitem:a7f73df3954a09c7ab0dca208b6b23ddd template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f73df3954a09c7ab0dca208b6b23ddd">visit</a> (Visitor &amp;func) const</td></tr>
<tr class="memitem:a148e20e32aa3ceca13e0a49c2cc584fc" id="r_a148e20e32aa3ceca13e0a49c2cc584fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a148e20e32aa3ceca13e0a49c2cc584fc">format</a> (const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;fmt) const</td></tr>
<tr class="memitem:a8da735a6bfc7012606acf787156d10a0" id="r_a8da735a6bfc7012606acf787156d10a0"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a> () const</td></tr>
<tr class="memitem:a1b2641cc14a6ad2ee9703df770c096af" id="r_a1b2641cc14a6ad2ee9703df770c096af"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b2641cc14a6ad2ee9703df770c096af">all</a> () const</td></tr>
<tr class="memitem:ae2fd88cfd0f2bf9cc493d0a29cbc8695" id="r_ae2fd88cfd0f2bf9cc493d0a29cbc8695"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2fd88cfd0f2bf9cc493d0a29cbc8695">any</a> () const</td></tr>
<tr class="memitem:a87e937cc19720ffc223c9a62484d0a61" id="r_a87e937cc19720ffc223c9a62484d0a61"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87e937cc19720ffc223c9a62484d0a61">count</a> () const</td></tr>
<tr class="memitem:af9662cd704ffc16c5b88c7b2d331576f" id="r_af9662cd704ffc16c5b88c7b2d331576f"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1VectorwiseOp.html">ConstRowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9662cd704ffc16c5b88c7b2d331576f">rowwise</a> () const</td></tr>
<tr class="memitem:ac1fbfd5b45f2b4b9bff9d1994e335863" id="r_ac1fbfd5b45f2b4b9bff9d1994e335863"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1VectorwiseOp.html">RowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1fbfd5b45f2b4b9bff9d1994e335863">rowwise</a> ()</td></tr>
<tr class="memitem:a978724c07b70cb9b8fdef67a4de08788" id="r_a978724c07b70cb9b8fdef67a4de08788"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1VectorwiseOp.html">ConstColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a978724c07b70cb9b8fdef67a4de08788">colwise</a> () const</td></tr>
<tr class="memitem:abfbb90acef01249a37f7d1323a414896" id="r_abfbb90acef01249a37f7d1323a414896"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1VectorwiseOp.html">ColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfbb90acef01249a37f7d1323a414896">colwise</a> ()</td></tr>
<tr class="memitem:a4b481a88facffd21b91754fba205607d" id="r_a4b481a88facffd21b91754fba205607d"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived, typename ElseDerived&gt; </td></tr>
<tr class="memitem:a4b481a88facffd21b91754fba205607d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, ElseDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b481a88facffd21b91754fba205607d">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="memitem:ae808c307d84c5a7a4e444edc409fdd44" id="r_ae808c307d84c5a7a4e444edc409fdd44"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived&gt; </td></tr>
<tr class="memitem:ae808c307d84c5a7a4e444edc409fdd44 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, typename ThenDerived::ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae808c307d84c5a7a4e444edc409fdd44">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const typename ThenDerived::Scalar &amp;elseScalar) const</td></tr>
<tr class="memitem:a5a3f75f1adaca52f8064d914d15af2af" id="r_a5a3f75f1adaca52f8064d914d15af2af"><td class="memTemplParams" colspan="2">template&lt;typename ElseDerived&gt; </td></tr>
<tr class="memitem:a5a3f75f1adaca52f8064d914d15af2af template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, typename ElseDerived::ConstantReturnType, ElseDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a3f75f1adaca52f8064d914d15af2af">select</a> (const typename ElseDerived::Scalar &amp;thenScalar, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="memitem:a7f4a720248190c3637a48e22ab66c835" id="r_a7f4a720248190c3637a48e22ab66c835"><td class="memTemplParams" colspan="2"><a id="a7f4a720248190c3637a48e22ab66c835" name="a7f4a720248190c3637a48e22ab66c835"></a>
template&lt;int p&gt; </td></tr>
<tr class="memitem:a7f4a720248190c3637a48e22ab66c835 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Product.html">RealScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lpNorm</b> () const</td></tr>
<tr class="memitem:ae36c50ce9e9d49a2b7a32ef54da5540c" id="r_ae36c50ce9e9d49a2b7a32ef54da5540c"><td class="memTemplParams" colspan="2">template&lt;int RowFactor, int ColFactor&gt; </td></tr>
<tr class="memitem:ae36c50ce9e9d49a2b7a32ef54da5540c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, RowFactor, ColFactor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae36c50ce9e9d49a2b7a32ef54da5540c">replicate</a> () const</td></tr>
<tr class="memitem:af9b5c151029f975956791322c5b7b919" id="r_af9b5c151029f975956791322c5b7b919"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9b5c151029f975956791322c5b7b919">replicate</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rowFactor, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> colFactor) const</td></tr>
<tr class="memitem:acde1eef3a99bbbb4ac694ca55b1764c8" id="r_acde1eef3a99bbbb4ac694ca55b1764c8"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acde1eef3a99bbbb4ac694ca55b1764c8">reverse</a> ()</td></tr>
<tr class="memitem:ada2ea028e35de0beef990fa0f6e3dee1" id="r_ada2ea028e35de0beef990fa0f6e3dee1"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada2ea028e35de0beef990fa0f6e3dee1">reverse</a> () const</td></tr>
<tr class="memitem:a11014cd4565501e332bdd38c0028f736" id="r_a11014cd4565501e332bdd38c0028f736"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11014cd4565501e332bdd38c0028f736">reverseInPlace</a> ()</td></tr>
<tr class="memitem:a57591454af931f9dffa71c9da28d5641" id="r_a57591454af931f9dffa71c9da28d5641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1true__type.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin</a> ()</td></tr>
<tr class="memitem:ad9368ce70b06167ec5fc19398d329f5e" id="r_ad9368ce70b06167ec5fc19398d329f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1true__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9368ce70b06167ec5fc19398d329f5e">begin</a> () const</td></tr>
<tr class="memitem:ae9a3dfd9b826ba3103de0128576fb15b" id="r_ae9a3dfd9b826ba3103de0128576fb15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1true__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9a3dfd9b826ba3103de0128576fb15b">cbegin</a> () const</td></tr>
<tr class="memitem:ae71d079e16d91360d10066b316b48485" id="r_ae71d079e16d91360d10066b316b48485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1true__type.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae71d079e16d91360d10066b316b48485">end</a> ()</td></tr>
<tr class="memitem:ab34773522e43bfb02e9cf652d7b5dd60" id="r_ab34773522e43bfb02e9cf652d7b5dd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1true__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab34773522e43bfb02e9cf652d7b5dd60">end</a> () const</td></tr>
<tr class="memitem:aeb3b76f02986c2af2521d07164b5ffde" id="r_aeb3b76f02986c2af2521d07164b5ffde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1true__type.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend</a> () const</td></tr>
<tr class="memitem:ae441c0556de0ce7d41812b52777ef3f4" id="r_ae441c0556de0ce7d41812b52777ef3f4"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NegativeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae441c0556de0ce7d41812b52777ef3f4">operator-</a> () const</td></tr>
<tr class="memitem:a15ea9409dfdf3c0737720ab383781fda" id="r_a15ea9409dfdf3c0737720ab383781fda"><td class="memTemplParams" colspan="2">template&lt;typename NewType&gt; </td></tr>
<tr class="memitem:a15ea9409dfdf3c0737720ab383781fda template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1DenseBase_1_1CastXpr.html">CastXpr</a>&lt; NewType &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15ea9409dfdf3c0737720ab383781fda">cast</a> () const</td></tr>
<tr class="memitem:a98af2017476fcc83444eea60afc4d15c" id="r_a98af2017476fcc83444eea60afc4d15c"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1true__type.html">ConjugateReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98af2017476fcc83444eea60afc4d15c">conjugate</a> () const</td></tr>
<tr class="memitem:a5ff2e805193f5cf5908225cd5c62a4db" id="r_a5ff2e805193f5cf5908225cd5c62a4db"><td class="memTemplParams" colspan="2">template&lt;bool Cond&gt; </td></tr>
<tr class="memitem:a5ff2e805193f5cf5908225cd5c62a4db template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Cond, <a class="el" href="structEigen_1_1internal_1_1true__type.html">ConjugateReturnType</a>, constDerived &amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ff2e805193f5cf5908225cd5c62a4db">conjugateIf</a> () const</td></tr>
<tr class="memitem:a655dc0515df0e0d487ed9ed9b39430e8" id="r_a655dc0515df0e0d487ed9ed9b39430e8"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1true__type.html">RealReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a655dc0515df0e0d487ed9ed9b39430e8">real</a> () const</td></tr>
<tr class="memitem:acd44cafedc27a8890afb535872d930a6" id="r_acd44cafedc27a8890afb535872d930a6"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">ImagReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd44cafedc27a8890afb535872d930a6">imag</a> () const</td></tr>
<tr class="memitem:a18bb16e6a73979ef9a348c82472bfb15" id="r_a18bb16e6a73979ef9a348c82472bfb15"><td class="memTemplParams" colspan="2">template&lt;typename CustomUnaryOp&gt; </td></tr>
<tr class="memitem:a18bb16e6a73979ef9a348c82472bfb15 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt; CustomUnaryOp, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18bb16e6a73979ef9a348c82472bfb15">unaryExpr</a> (const CustomUnaryOp &amp;func=CustomUnaryOp()) const</td></tr>
<tr class="memdesc:a18bb16e6a73979ef9a348c82472bfb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a unary operator coefficient-wise.  <br /></td></tr>
<tr class="memitem:a6332da04d6616c32f59259c4d70416ef" id="r_a6332da04d6616c32f59259c4d70416ef"><td class="memTemplParams" colspan="2">template&lt;typename CustomViewOp&gt; </td></tr>
<tr class="memitem:a6332da04d6616c32f59259c4d70416ef template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt; CustomViewOp, const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6332da04d6616c32f59259c4d70416ef">unaryViewExpr</a> (const CustomViewOp &amp;func=CustomViewOp()) const</td></tr>
<tr class="memitem:a4e7019de158be0384a19273713c74442" id="r_a4e7019de158be0384a19273713c74442"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1true__type.html">NonConstRealReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e7019de158be0384a19273713c74442">real</a> ()</td></tr>
<tr class="memitem:ac538fdacbe2592b11174abb2049a9656" id="r_ac538fdacbe2592b11174abb2049a9656"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1CwiseUnaryView.html">NonConstImagReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac538fdacbe2592b11174abb2049a9656">imag</a> ()</td></tr>
<tr class="memitem:aea3e98d95cd47acce1bf5721f573ed70" id="r_aea3e98d95cd47acce1bf5721f573ed70"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:aea3e98d95cd47acce1bf5721f573ed70 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, NRowsType blockRows, NColsType blockCols)</td></tr>
<tr class="memitem:a6e81891937250cbd2eccc332efb387ac" id="r_a6e81891937250cbd2eccc332efb387ac"><td class="memTemplParams" colspan="2"><a id="a6e81891937250cbd2eccc332efb387ac" name="a6e81891937250cbd2eccc332efb387ac"></a>
template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a6e81891937250cbd2eccc332efb387ac template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>block</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, NRowsType blockRows, NColsType blockCols) const</td></tr>
<tr class="memdesc:a6e81891937250cbd2eccc332efb387ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a> <br /></td></tr>
<tr class="memitem:aeaca1c01dde5d29db181a2661b48807d" id="r_aeaca1c01dde5d29db181a2661b48807d"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:aeaca1c01dde5d29db181a2661b48807d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaca1c01dde5d29db181a2661b48807d">topRightCorner</a> (NRowsType cRows, NColsType cCols)</td></tr>
<tr class="memitem:a678beed790d3c805c7bf5c6fee87018f" id="r_a678beed790d3c805c7bf5c6fee87018f"><td class="memTemplParams" colspan="2"><a id="a678beed790d3c805c7bf5c6fee87018f" name="a678beed790d3c805c7bf5c6fee87018f"></a>
template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a678beed790d3c805c7bf5c6fee87018f template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topRightCorner</b> (NRowsType cRows, NColsType cCols) const</td></tr>
<tr class="memdesc:a678beed790d3c805c7bf5c6fee87018f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#aeaca1c01dde5d29db181a2661b48807d">topRightCorner(NRowsType, NColsType)</a>. <br /></td></tr>
<tr class="memitem:a46522717e54d3178d053d11832eb5b9a" id="r_a46522717e54d3178d053d11832eb5b9a"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a46522717e54d3178d053d11832eb5b9a template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46522717e54d3178d053d11832eb5b9a">topRightCorner</a> ()</td></tr>
<tr class="memitem:a0df02f88f5a492ebaeb2909bc8f07bbd" id="r_a0df02f88f5a492ebaeb2909bc8f07bbd"><td class="memTemplParams" colspan="2"><a id="a0df02f88f5a492ebaeb2909bc8f07bbd" name="a0df02f88f5a492ebaeb2909bc8f07bbd"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a0df02f88f5a492ebaeb2909bc8f07bbd template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topRightCorner</b> () const</td></tr>
<tr class="memdesc:a0df02f88f5a492ebaeb2909bc8f07bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a46522717e54d3178d053d11832eb5b9a">topRightCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="memitem:aa568d28749715cd0363778c843bd1770" id="r_aa568d28749715cd0363778c843bd1770"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:aa568d28749715cd0363778c843bd1770 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa568d28749715cd0363778c843bd1770">topRightCorner</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols)</td></tr>
<tr class="memitem:ad8c770c5b050ef3f6d1466a35493418d" id="r_ad8c770c5b050ef3f6d1466a35493418d"><td class="memTemplParams" colspan="2"><a id="ad8c770c5b050ef3f6d1466a35493418d" name="ad8c770c5b050ef3f6d1466a35493418d"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ad8c770c5b050ef3f6d1466a35493418d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topRightCorner</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols) const</td></tr>
<tr class="memdesc:ad8c770c5b050ef3f6d1466a35493418d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#aa568d28749715cd0363778c843bd1770">topRightCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="memitem:a19c05b545831778f587c26236e0eefa3" id="r_a19c05b545831778f587c26236e0eefa3"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a19c05b545831778f587c26236e0eefa3 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19c05b545831778f587c26236e0eefa3">topLeftCorner</a> (NRowsType cRows, NColsType cCols)</td></tr>
<tr class="memitem:a0a0a4c0b52d3e4fc3c2fbdf571236869" id="r_a0a0a4c0b52d3e4fc3c2fbdf571236869"><td class="memTemplParams" colspan="2"><a id="a0a0a4c0b52d3e4fc3c2fbdf571236869" name="a0a0a4c0b52d3e4fc3c2fbdf571236869"></a>
template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a0a0a4c0b52d3e4fc3c2fbdf571236869 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topLeftCorner</b> (NRowsType cRows, NColsType cCols) const</td></tr>
<tr class="memdesc:a0a0a4c0b52d3e4fc3c2fbdf571236869"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a0458abf04c04cbb12c65aa7270c6be0c">topLeftCorner(Index, Index)</a>. <br /></td></tr>
<tr class="memitem:a1ecceaddc1f9f721934e92d8fa457238" id="r_a1ecceaddc1f9f721934e92d8fa457238"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a1ecceaddc1f9f721934e92d8fa457238 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ecceaddc1f9f721934e92d8fa457238">topLeftCorner</a> ()</td></tr>
<tr class="memitem:a36c92f2095d347c7bde038a0b5824e7a" id="r_a36c92f2095d347c7bde038a0b5824e7a"><td class="memTemplParams" colspan="2"><a id="a36c92f2095d347c7bde038a0b5824e7a" name="a36c92f2095d347c7bde038a0b5824e7a"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a36c92f2095d347c7bde038a0b5824e7a template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topLeftCorner</b> () const</td></tr>
<tr class="memdesc:a36c92f2095d347c7bde038a0b5824e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a1ecceaddc1f9f721934e92d8fa457238">topLeftCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a0458abf04c04cbb12c65aa7270c6be0c" id="r_a0458abf04c04cbb12c65aa7270c6be0c"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a0458abf04c04cbb12c65aa7270c6be0c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0458abf04c04cbb12c65aa7270c6be0c">topLeftCorner</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols)</td></tr>
<tr class="memitem:a0178f408acaca475290b6f12e95eae6c" id="r_a0178f408acaca475290b6f12e95eae6c"><td class="memTemplParams" colspan="2"><a id="a0178f408acaca475290b6f12e95eae6c" name="a0178f408acaca475290b6f12e95eae6c"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a0178f408acaca475290b6f12e95eae6c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topLeftCorner</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols) const</td></tr>
<tr class="memdesc:a0178f408acaca475290b6f12e95eae6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a0458abf04c04cbb12c65aa7270c6be0c">topLeftCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="memitem:a19cd1740bbda13b82fb22a4a05ff3138" id="r_a19cd1740bbda13b82fb22a4a05ff3138"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a19cd1740bbda13b82fb22a4a05ff3138 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19cd1740bbda13b82fb22a4a05ff3138">bottomRightCorner</a> (NRowsType cRows, NColsType cCols)</td></tr>
<tr class="memitem:ad98f5296be8c2c90808a2dde6def5cbf" id="r_ad98f5296be8c2c90808a2dde6def5cbf"><td class="memTemplParams" colspan="2"><a id="ad98f5296be8c2c90808a2dde6def5cbf" name="ad98f5296be8c2c90808a2dde6def5cbf"></a>
template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:ad98f5296be8c2c90808a2dde6def5cbf template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomRightCorner</b> (NRowsType cRows, NColsType cCols) const</td></tr>
<tr class="memdesc:ad98f5296be8c2c90808a2dde6def5cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a19cd1740bbda13b82fb22a4a05ff3138">bottomRightCorner(NRowsType, NColsType)</a>. <br /></td></tr>
<tr class="memitem:afe32b5faeae3a2d37248f3e7901f6f34" id="r_afe32b5faeae3a2d37248f3e7901f6f34"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:afe32b5faeae3a2d37248f3e7901f6f34 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe32b5faeae3a2d37248f3e7901f6f34">bottomRightCorner</a> ()</td></tr>
<tr class="memitem:a08e84584ff563e9e22f17648e430eb46" id="r_a08e84584ff563e9e22f17648e430eb46"><td class="memTemplParams" colspan="2"><a id="a08e84584ff563e9e22f17648e430eb46" name="a08e84584ff563e9e22f17648e430eb46"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a08e84584ff563e9e22f17648e430eb46 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomRightCorner</b> () const</td></tr>
<tr class="memdesc:a08e84584ff563e9e22f17648e430eb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#afe32b5faeae3a2d37248f3e7901f6f34">bottomRightCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="memitem:adad3e30a0aa43af05c3a8eec8a46e68a" id="r_adad3e30a0aa43af05c3a8eec8a46e68a"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:adad3e30a0aa43af05c3a8eec8a46e68a template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adad3e30a0aa43af05c3a8eec8a46e68a">bottomRightCorner</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols)</td></tr>
<tr class="memitem:a628a1d29e7da93da1b2d3786840ea589" id="r_a628a1d29e7da93da1b2d3786840ea589"><td class="memTemplParams" colspan="2"><a id="a628a1d29e7da93da1b2d3786840ea589" name="a628a1d29e7da93da1b2d3786840ea589"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a628a1d29e7da93da1b2d3786840ea589 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomRightCorner</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols) const</td></tr>
<tr class="memdesc:a628a1d29e7da93da1b2d3786840ea589"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#adad3e30a0aa43af05c3a8eec8a46e68a">bottomRightCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="memitem:aad9b045f3effb89a9beee0e40ecbe5ba" id="r_aad9b045f3effb89a9beee0e40ecbe5ba"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:aad9b045f3effb89a9beee0e40ecbe5ba template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad9b045f3effb89a9beee0e40ecbe5ba">bottomLeftCorner</a> (NRowsType cRows, NColsType cCols)</td></tr>
<tr class="memitem:a132a487877bb7a0562e00e28c2c1d693" id="r_a132a487877bb7a0562e00e28c2c1d693"><td class="memTemplParams" colspan="2"><a id="a132a487877bb7a0562e00e28c2c1d693" name="a132a487877bb7a0562e00e28c2c1d693"></a>
template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a132a487877bb7a0562e00e28c2c1d693 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomLeftCorner</b> (NRowsType cRows, NColsType cCols) const</td></tr>
<tr class="memdesc:a132a487877bb7a0562e00e28c2c1d693"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#aad9b045f3effb89a9beee0e40ecbe5ba">bottomLeftCorner(NRowsType, NColsType)</a>. <br /></td></tr>
<tr class="memitem:a9d8d812af4bbff232cbf5ff1075841b6" id="r_a9d8d812af4bbff232cbf5ff1075841b6"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a9d8d812af4bbff232cbf5ff1075841b6 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d8d812af4bbff232cbf5ff1075841b6">bottomLeftCorner</a> ()</td></tr>
<tr class="memitem:a2b146523dcb3bb25143dba5e858f9379" id="r_a2b146523dcb3bb25143dba5e858f9379"><td class="memTemplParams" colspan="2"><a id="a2b146523dcb3bb25143dba5e858f9379" name="a2b146523dcb3bb25143dba5e858f9379"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a2b146523dcb3bb25143dba5e858f9379 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomLeftCorner</b> () const</td></tr>
<tr class="memdesc:a2b146523dcb3bb25143dba5e858f9379"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a9d8d812af4bbff232cbf5ff1075841b6">bottomLeftCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a40f6bc69ea4aaf31d905a1cff2fcaed2" id="r_a40f6bc69ea4aaf31d905a1cff2fcaed2"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a40f6bc69ea4aaf31d905a1cff2fcaed2 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40f6bc69ea4aaf31d905a1cff2fcaed2">bottomLeftCorner</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols)</td></tr>
<tr class="memitem:a9b0a5fd012170405c747f3cef63cc730" id="r_a9b0a5fd012170405c747f3cef63cc730"><td class="memTemplParams" colspan="2"><a id="a9b0a5fd012170405c747f3cef63cc730" name="a9b0a5fd012170405c747f3cef63cc730"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a9b0a5fd012170405c747f3cef63cc730 template"><td class="memItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; CRows, CCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomLeftCorner</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cCols) const</td></tr>
<tr class="memdesc:a9b0a5fd012170405c747f3cef63cc730"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a40f6bc69ea4aaf31d905a1cff2fcaed2">bottomLeftCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="memitem:aee7e190ad2aa5567b5e4497f1e5ea137" id="r_aee7e190ad2aa5567b5e4497f1e5ea137"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType&gt; </td></tr>
<tr class="memitem:aee7e190ad2aa5567b5e4497f1e5ea137 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee7e190ad2aa5567b5e4497f1e5ea137">topRows</a> (NRowsType n)</td></tr>
<tr class="memitem:ab6df6ec0f78206c9bfd83695fe0f17c5" id="r_ab6df6ec0f78206c9bfd83695fe0f17c5"><td class="memTemplParams" colspan="2"><a id="ab6df6ec0f78206c9bfd83695fe0f17c5" name="ab6df6ec0f78206c9bfd83695fe0f17c5"></a>
template&lt;typename NRowsType&gt; </td></tr>
<tr class="memitem:ab6df6ec0f78206c9bfd83695fe0f17c5 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstNRowsBlockXpr.html">ConstNRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topRows</b> (NRowsType n) const</td></tr>
<tr class="memdesc:ab6df6ec0f78206c9bfd83695fe0f17c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#aee7e190ad2aa5567b5e4497f1e5ea137">topRows(NRowsType)</a>. <br /></td></tr>
<tr class="memitem:aee644f2f7050a8fbc7e5873d6d6df236" id="r_aee644f2f7050a8fbc7e5873d6d6df236"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aee644f2f7050a8fbc7e5873d6d6df236 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee644f2f7050a8fbc7e5873d6d6df236">topRows</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:adcc761c63c1937655c771d2592ebf8e0" id="r_adcc761c63c1937655c771d2592ebf8e0"><td class="memTemplParams" colspan="2"><a id="adcc761c63c1937655c771d2592ebf8e0" name="adcc761c63c1937655c771d2592ebf8e0"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:adcc761c63c1937655c771d2592ebf8e0 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstNRowsBlockXpr.html">ConstNRowsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>topRows</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:adcc761c63c1937655c771d2592ebf8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#aee7e190ad2aa5567b5e4497f1e5ea137">topRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a28ee74c24455d38d3248451122fa080a" id="r_a28ee74c24455d38d3248451122fa080a"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType&gt; </td></tr>
<tr class="memitem:a28ee74c24455d38d3248451122fa080a template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28ee74c24455d38d3248451122fa080a">bottomRows</a> (NRowsType n)</td></tr>
<tr class="memitem:a85a680429dabe657ba552dcb9ddc09a5" id="r_a85a680429dabe657ba552dcb9ddc09a5"><td class="memTemplParams" colspan="2"><a id="a85a680429dabe657ba552dcb9ddc09a5" name="a85a680429dabe657ba552dcb9ddc09a5"></a>
template&lt;typename NRowsType&gt; </td></tr>
<tr class="memitem:a85a680429dabe657ba552dcb9ddc09a5 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstNRowsBlockXpr.html">ConstNRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomRows</b> (NRowsType n) const</td></tr>
<tr class="memdesc:a85a680429dabe657ba552dcb9ddc09a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a28ee74c24455d38d3248451122fa080a">bottomRows(NRowsType)</a>. <br /></td></tr>
<tr class="memitem:a5bf5b481c9ee87ed68a33325f82d6c8c" id="r_a5bf5b481c9ee87ed68a33325f82d6c8c"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a5bf5b481c9ee87ed68a33325f82d6c8c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf5b481c9ee87ed68a33325f82d6c8c">bottomRows</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:a1271d343f19fad4c6747ea2b54b72438" id="r_a1271d343f19fad4c6747ea2b54b72438"><td class="memTemplParams" colspan="2"><a id="a1271d343f19fad4c6747ea2b54b72438" name="a1271d343f19fad4c6747ea2b54b72438"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a1271d343f19fad4c6747ea2b54b72438 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstNRowsBlockXpr.html">ConstNRowsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>bottomRows</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:a1271d343f19fad4c6747ea2b54b72438"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a28ee74c24455d38d3248451122fa080a">bottomRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a0c9b37290b2c800d29eb33e168a4121c" id="r_a0c9b37290b2c800d29eb33e168a4121c"><td class="memTemplParams" colspan="2">template&lt;typename NRowsType&gt; </td></tr>
<tr class="memitem:a0c9b37290b2c800d29eb33e168a4121c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9b37290b2c800d29eb33e168a4121c">middleRows</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, NRowsType n)</td></tr>
<tr class="memitem:aabe5d260238a523127cd00c6fefd2314" id="r_aabe5d260238a523127cd00c6fefd2314"><td class="memTemplParams" colspan="2"><a id="aabe5d260238a523127cd00c6fefd2314" name="aabe5d260238a523127cd00c6fefd2314"></a>
template&lt;typename NRowsType&gt; </td></tr>
<tr class="memitem:aabe5d260238a523127cd00c6fefd2314 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstNRowsBlockXpr.html">ConstNRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>middleRows</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, NRowsType n) const</td></tr>
<tr class="memdesc:aabe5d260238a523127cd00c6fefd2314"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a0c9b37290b2c800d29eb33e168a4121c">middleRows(Index,NRowsType)</a>. <br /></td></tr>
<tr class="memitem:a34a005af1e93ee45aaa3e994ddc69201" id="r_a34a005af1e93ee45aaa3e994ddc69201"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a34a005af1e93ee45aaa3e994ddc69201 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34a005af1e93ee45aaa3e994ddc69201">middleRows</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:a58fb01b4e5029088ab458193c9dfd84a" id="r_a58fb01b4e5029088ab458193c9dfd84a"><td class="memTemplParams" colspan="2"><a id="a58fb01b4e5029088ab458193c9dfd84a" name="a58fb01b4e5029088ab458193c9dfd84a"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a58fb01b4e5029088ab458193c9dfd84a template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstNRowsBlockXpr.html">ConstNRowsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>middleRows</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:a58fb01b4e5029088ab458193c9dfd84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a0c9b37290b2c800d29eb33e168a4121c">middleRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a37c9f9574c5c2b6dcda11ef2adbf0f2b" id="r_a37c9f9574c5c2b6dcda11ef2adbf0f2b"><td class="memTemplParams" colspan="2">template&lt;typename NColsType&gt; </td></tr>
<tr class="memitem:a37c9f9574c5c2b6dcda11ef2adbf0f2b template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37c9f9574c5c2b6dcda11ef2adbf0f2b">leftCols</a> (NColsType n)</td></tr>
<tr class="memitem:a43db73f06bd251030b0491299e23b1cf" id="r_a43db73f06bd251030b0491299e23b1cf"><td class="memTemplParams" colspan="2"><a id="a43db73f06bd251030b0491299e23b1cf" name="a43db73f06bd251030b0491299e23b1cf"></a>
template&lt;typename NColsType&gt; </td></tr>
<tr class="memitem:a43db73f06bd251030b0491299e23b1cf template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstNColsBlockXpr.html">ConstNColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>leftCols</b> (NColsType n) const</td></tr>
<tr class="memdesc:a43db73f06bd251030b0491299e23b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a37c9f9574c5c2b6dcda11ef2adbf0f2b">leftCols(NColsType)</a>. <br /></td></tr>
<tr class="memitem:afc1420dda5e5572d29950b6a9f23ee16" id="r_afc1420dda5e5572d29950b6a9f23ee16"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:afc1420dda5e5572d29950b6a9f23ee16 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc1420dda5e5572d29950b6a9f23ee16">leftCols</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:aa9f22848da0835a2bcb3dbe18db8912c" id="r_aa9f22848da0835a2bcb3dbe18db8912c"><td class="memTemplParams" colspan="2"><a id="aa9f22848da0835a2bcb3dbe18db8912c" name="aa9f22848da0835a2bcb3dbe18db8912c"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:aa9f22848da0835a2bcb3dbe18db8912c template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstNColsBlockXpr.html">ConstNColsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>leftCols</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:aa9f22848da0835a2bcb3dbe18db8912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a37c9f9574c5c2b6dcda11ef2adbf0f2b">leftCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a6835fcaaf239e3e5ed2fd12e6d41566d" id="r_a6835fcaaf239e3e5ed2fd12e6d41566d"><td class="memTemplParams" colspan="2">template&lt;typename NColsType&gt; </td></tr>
<tr class="memitem:a6835fcaaf239e3e5ed2fd12e6d41566d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6835fcaaf239e3e5ed2fd12e6d41566d">rightCols</a> (NColsType n)</td></tr>
<tr class="memitem:aca6df6123155464b03bd3d4ac3d29097" id="r_aca6df6123155464b03bd3d4ac3d29097"><td class="memTemplParams" colspan="2"><a id="aca6df6123155464b03bd3d4ac3d29097" name="aca6df6123155464b03bd3d4ac3d29097"></a>
template&lt;typename NColsType&gt; </td></tr>
<tr class="memitem:aca6df6123155464b03bd3d4ac3d29097 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstNColsBlockXpr.html">ConstNColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>rightCols</b> (NColsType n) const</td></tr>
<tr class="memdesc:aca6df6123155464b03bd3d4ac3d29097"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a6835fcaaf239e3e5ed2fd12e6d41566d">rightCols(NColsType)</a>. <br /></td></tr>
<tr class="memitem:af5e466f472f91afd86925c68925525f7" id="r_af5e466f472f91afd86925c68925525f7"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:af5e466f472f91afd86925c68925525f7 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e466f472f91afd86925c68925525f7">rightCols</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:af0ba29d67b486d1c244a2620abe2e853" id="r_af0ba29d67b486d1c244a2620abe2e853"><td class="memTemplParams" colspan="2"><a id="af0ba29d67b486d1c244a2620abe2e853" name="af0ba29d67b486d1c244a2620abe2e853"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:af0ba29d67b486d1c244a2620abe2e853 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstNColsBlockXpr.html">ConstNColsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>rightCols</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:af0ba29d67b486d1c244a2620abe2e853"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a6835fcaaf239e3e5ed2fd12e6d41566d">rightCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a79e225dc7b4e6c052a36c1bac2ce55a1" id="r_a79e225dc7b4e6c052a36c1bac2ce55a1"><td class="memTemplParams" colspan="2">template&lt;typename NColsType&gt; </td></tr>
<tr class="memitem:a79e225dc7b4e6c052a36c1bac2ce55a1 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79e225dc7b4e6c052a36c1bac2ce55a1">middleCols</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, NColsType numCols)</td></tr>
<tr class="memitem:aa3622a8baa85349c13f20bd15c5788f0" id="r_aa3622a8baa85349c13f20bd15c5788f0"><td class="memTemplParams" colspan="2"><a id="aa3622a8baa85349c13f20bd15c5788f0" name="aa3622a8baa85349c13f20bd15c5788f0"></a>
template&lt;typename NColsType&gt; </td></tr>
<tr class="memitem:aa3622a8baa85349c13f20bd15c5788f0 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstNColsBlockXpr.html">ConstNColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>middleCols</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, NColsType numCols) const</td></tr>
<tr class="memdesc:aa3622a8baa85349c13f20bd15c5788f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a79e225dc7b4e6c052a36c1bac2ce55a1">middleCols(Index,NColsType)</a>. <br /></td></tr>
<tr class="memitem:affbd287191d45cf87dd419e77b7d3ff9" id="r_affbd287191d45cf87dd419e77b7d3ff9"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:affbd287191d45cf87dd419e77b7d3ff9 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affbd287191d45cf87dd419e77b7d3ff9">middleCols</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:a9df202d381961fba30ca89f715ec06dc" id="r_a9df202d381961fba30ca89f715ec06dc"><td class="memTemplParams" colspan="2"><a id="a9df202d381961fba30ca89f715ec06dc" name="a9df202d381961fba30ca89f715ec06dc"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a9df202d381961fba30ca89f715ec06dc template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstNColsBlockXpr.html">ConstNColsBlockXpr</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>middleCols</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:a9df202d381961fba30ca89f715ec06dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a79e225dc7b4e6c052a36c1bac2ce55a1">middleCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a20ca095fbf288a393066b0e08a504280" id="r_a20ca095fbf288a393066b0e08a504280"><td class="memTemplParams" colspan="2">template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:a20ca095fbf288a393066b0e08a504280 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; NRows, NCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20ca095fbf288a393066b0e08a504280">block</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol)</td></tr>
<tr class="memitem:a5fe374f1ffe270e62040f0e3d43a101d" id="r_a5fe374f1ffe270e62040f0e3d43a101d"><td class="memTemplParams" colspan="2"><a id="a5fe374f1ffe270e62040f0e3d43a101d" name="a5fe374f1ffe270e62040f0e3d43a101d"></a>
template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:a5fe374f1ffe270e62040f0e3d43a101d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; NRows, NCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>block</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol) const</td></tr>
<tr class="memdesc:a5fe374f1ffe270e62040f0e3d43a101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a20ca095fbf288a393066b0e08a504280">block&lt;&gt;(Index, Index)</a>. *&zwj;/. <br /></td></tr>
<tr class="memitem:adf40a0b66634af3002950c915ed15950" id="r_adf40a0b66634af3002950c915ed15950"><td class="memTemplParams" colspan="2">template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:adf40a0b66634af3002950c915ed15950 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; NRows, NCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf40a0b66634af3002950c915ed15950">block</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> blockRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> blockCols)</td></tr>
<tr class="memitem:af71c782c36d77658d8382fedeeb13086" id="r_af71c782c36d77658d8382fedeeb13086"><td class="memTemplParams" colspan="2"><a id="af71c782c36d77658d8382fedeeb13086" name="af71c782c36d77658d8382fedeeb13086"></a>
template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:af71c782c36d77658d8382fedeeb13086 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedBlockXpr.html">ConstFixedBlockXpr</a>&lt; NRows, NCols &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>block</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startRow, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> startCol, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> blockRows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> blockCols) const</td></tr>
<tr class="memdesc:af71c782c36d77658d8382fedeeb13086"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#adf40a0b66634af3002950c915ed15950">block&lt;&gt;(Index, Index, Index, Index)</a>. <br /></td></tr>
<tr class="memitem:ad0c05525967c16738c2cd2285b38a91f" id="r_ad0c05525967c16738c2cd2285b38a91f"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">ColXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c05525967c16738c2cd2285b38a91f">col</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i)</td></tr>
<tr class="memitem:ae28fccee460e2ba2a552b898a7b8815f" id="r_ae28fccee460e2ba2a552b898a7b8815f"><td class="memItemLeft" align="right" valign="top"><a id="ae28fccee460e2ba2a552b898a7b8815f" name="ae28fccee460e2ba2a552b898a7b8815f"></a>
EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">ConstColXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>col</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i) const</td></tr>
<tr class="memdesc:ae28fccee460e2ba2a552b898a7b8815f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#ad0c05525967c16738c2cd2285b38a91f">col()</a>. <br /></td></tr>
<tr class="memitem:ac4c69272b7de4fae22f5f13968fb6703" id="r_ac4c69272b7de4fae22f5f13968fb6703"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">RowXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4c69272b7de4fae22f5f13968fb6703">row</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i)</td></tr>
<tr class="memitem:ae3d48f4ffa012585ff98b9b08b144ac4" id="r_ae3d48f4ffa012585ff98b9b08b144ac4"><td class="memItemLeft" align="right" valign="top"><a id="ae3d48f4ffa012585ff98b9b08b144ac4" name="ae3d48f4ffa012585ff98b9b08b144ac4"></a>
EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">ConstRowXpr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>row</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i) const</td></tr>
<tr class="memdesc:ae3d48f4ffa012585ff98b9b08b144ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#ac4c69272b7de4fae22f5f13968fb6703">row()</a>. *&zwj;/. <br /></td></tr>
<tr class="memitem:ab4bf41770a8db6522d472d05c7cbced8" id="r_ab4bf41770a8db6522d472d05c7cbced8"><td class="memTemplParams" colspan="2">template&lt;typename NType&gt; </td></tr>
<tr class="memitem:ab4bf41770a8db6522d472d05c7cbced8 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4bf41770a8db6522d472d05c7cbced8">segment</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> start, NType n)</td></tr>
<tr class="memitem:ac9cc88d886f062fd76dbf29519c48bb2" id="r_ac9cc88d886f062fd76dbf29519c48bb2"><td class="memTemplParams" colspan="2"><a id="ac9cc88d886f062fd76dbf29519c48bb2" name="ac9cc88d886f062fd76dbf29519c48bb2"></a>
template&lt;typename NType&gt; </td></tr>
<tr class="memitem:ac9cc88d886f062fd76dbf29519c48bb2 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedSegmentReturnType.html">ConstFixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>segment</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> start, NType n) const</td></tr>
<tr class="memdesc:ac9cc88d886f062fd76dbf29519c48bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#ab4bf41770a8db6522d472d05c7cbced8">segment(Index,NType)</a>. <br /></td></tr>
<tr class="memitem:a193b8eb3608c4f77a1852fe8546e364e" id="r_a193b8eb3608c4f77a1852fe8546e364e"><td class="memTemplParams" colspan="2">template&lt;typename NType&gt; </td></tr>
<tr class="memitem:a193b8eb3608c4f77a1852fe8546e364e template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193b8eb3608c4f77a1852fe8546e364e">head</a> (NType n)</td></tr>
<tr class="memitem:a9a0d5c0cbbdf38f9b8ffd0f1c90eeda8" id="r_a9a0d5c0cbbdf38f9b8ffd0f1c90eeda8"><td class="memTemplParams" colspan="2"><a id="a9a0d5c0cbbdf38f9b8ffd0f1c90eeda8" name="a9a0d5c0cbbdf38f9b8ffd0f1c90eeda8"></a>
template&lt;typename NType&gt; </td></tr>
<tr class="memitem:a9a0d5c0cbbdf38f9b8ffd0f1c90eeda8 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedSegmentReturnType.html">ConstFixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>head</b> (NType n) const</td></tr>
<tr class="memdesc:a9a0d5c0cbbdf38f9b8ffd0f1c90eeda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a193b8eb3608c4f77a1852fe8546e364e">head(NType)</a>. <br /></td></tr>
<tr class="memitem:ac2b0d76db0790618c5ac2c4dbb723d18" id="r_ac2b0d76db0790618c5ac2c4dbb723d18"><td class="memTemplParams" colspan="2">template&lt;typename NType&gt; </td></tr>
<tr class="memitem:ac2b0d76db0790618c5ac2c4dbb723d18 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2b0d76db0790618c5ac2c4dbb723d18">tail</a> (NType n)</td></tr>
<tr class="memitem:a8912100730abbad6fb214f563ea61df6" id="r_a8912100730abbad6fb214f563ea61df6"><td class="memTemplParams" colspan="2"><a id="a8912100730abbad6fb214f563ea61df6" name="a8912100730abbad6fb214f563ea61df6"></a>
template&lt;typename NType&gt; </td></tr>
<tr class="memitem:a8912100730abbad6fb214f563ea61df6 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedSegmentReturnType.html">ConstFixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>tail</b> (NType n) const</td></tr>
<tr class="memdesc:a8912100730abbad6fb214f563ea61df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a08564a0fb59f2ba7eee05bd539a07135">tail(Index)</a>. <br /></td></tr>
<tr class="memitem:a2b3627ef4c1ce521e46f439ea393f445" id="r_a2b3627ef4c1ce521e46f439ea393f445"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a2b3627ef4c1ce521e46f439ea393f445 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b3627ef4c1ce521e46f439ea393f445">segment</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> start, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:a8393554e931212613ae097a7ae98df43" id="r_a8393554e931212613ae097a7ae98df43"><td class="memTemplParams" colspan="2"><a id="a8393554e931212613ae097a7ae98df43" name="a8393554e931212613ae097a7ae98df43"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a8393554e931212613ae097a7ae98df43 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedSegmentReturnType.html">ConstFixedSegmentReturnType</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>segment</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> start, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:a8393554e931212613ae097a7ae98df43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of segment&lt;int&gt;(Index). <br /></td></tr>
<tr class="memitem:afc17b9ee8005befcf6929adf5eb0aa65" id="r_afc17b9ee8005befcf6929adf5eb0aa65"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:afc17b9ee8005befcf6929adf5eb0aa65 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc17b9ee8005befcf6929adf5eb0aa65">head</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:a4cea644a8821c5e39bf7336c1d27dbcf" id="r_a4cea644a8821c5e39bf7336c1d27dbcf"><td class="memTemplParams" colspan="2"><a id="a4cea644a8821c5e39bf7336c1d27dbcf" name="a4cea644a8821c5e39bf7336c1d27dbcf"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a4cea644a8821c5e39bf7336c1d27dbcf template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedSegmentReturnType.html">ConstFixedSegmentReturnType</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>head</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:a4cea644a8821c5e39bf7336c1d27dbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="#a193b8eb3608c4f77a1852fe8546e364e">head&lt;int&gt;()</a>. <br /></td></tr>
<tr class="memitem:a08564a0fb59f2ba7eee05bd539a07135" id="r_a08564a0fb59f2ba7eee05bd539a07135"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a08564a0fb59f2ba7eee05bd539a07135 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08564a0fb59f2ba7eee05bd539a07135">tail</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N)</td></tr>
<tr class="memitem:a7bdf6bd69559ad44d24636f68fdb226e" id="r_a7bdf6bd69559ad44d24636f68fdb226e"><td class="memTemplParams" colspan="2"><a id="a7bdf6bd69559ad44d24636f68fdb226e" name="a7bdf6bd69559ad44d24636f68fdb226e"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a7bdf6bd69559ad44d24636f68fdb226e template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1ConstFixedSegmentReturnType.html">ConstFixedSegmentReturnType</a>&lt; N &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>tail</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> n=N) const</td></tr>
<tr class="memdesc:a7bdf6bd69559ad44d24636f68fdb226e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of tail&lt;int&gt;. <br /></td></tr>
<tr class="memitem:a11c151e4309a3ba9ab9d0e6501f7cab1" id="r_a11c151e4309a3ba9ab9d0e6501f7cab1"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">InnerVectorReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11c151e4309a3ba9ab9d0e6501f7cab1">innerVector</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer)</td></tr>
<tr class="memitem:a7bbdb86fa945665fe63872a5f80d058e" id="r_a7bbdb86fa945665fe63872a5f80d058e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1Block.html">ConstInnerVectorReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bbdb86fa945665fe63872a5f80d058e">innerVector</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer) const</td></tr>
<tr class="memitem:a6cc6206d125d7c10a40f80574eff93a9" id="r_a6cc6206d125d7c10a40f80574eff93a9"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">InnerVectorsReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cc6206d125d7c10a40f80574eff93a9">innerVectors</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outerStart, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a1e002168ce504d56d923e54463ae6553">outerSize</a>)</td></tr>
<tr class="memitem:ae899184d8fe026b50169ae01287f33b3" id="r_ae899184d8fe026b50169ae01287f33b3"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1Block.html">ConstInnerVectorsReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae899184d8fe026b50169ae01287f33b3">innerVectors</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outerStart, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="#a1e002168ce504d56d923e54463ae6553">outerSize</a>) const</td></tr>
<tr class="memitem:aa9ae074fb95265bf28eae0570950cc23" id="r_aa9ae074fb95265bf28eae0570950cc23"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> Direction&gt; </td></tr>
<tr class="memitem:aa9ae074fb95265bf28eae0570950cc23 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Direction==<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>, <a class="el" href="classEigen_1_1Block.html">ColXpr</a>, <a class="el" href="classEigen_1_1Block.html">RowXpr</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9ae074fb95265bf28eae0570950cc23">subVector</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i)</td></tr>
<tr class="memitem:a06e44b4dd3c95433bf22f144fa9d08ba" id="r_a06e44b4dd3c95433bf22f144fa9d08ba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> Direction&gt; </td></tr>
<tr class="memitem:a06e44b4dd3c95433bf22f144fa9d08ba template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Direction==<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>, <a class="el" href="classEigen_1_1Block.html">ConstColXpr</a>, <a class="el" href="classEigen_1_1Block.html">ConstRowXpr</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06e44b4dd3c95433bf22f144fa9d08ba">subVector</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i) const</td></tr>
<tr class="memitem:a949d26e45aa6df9e2d2abd4e184193cc" id="r_a949d26e45aa6df9e2d2abd4e184193cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> Direction&gt; </td></tr>
<tr class="memitem:a949d26e45aa6df9e2d2abd4e184193cc template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a949d26e45aa6df9e2d2abd4e184193cc">subVectors</a> () const</td></tr>
<tr class="memitem:a4ab85c7f3859f871bda589ee9cba93f2" id="r_a4ab85c7f3859f871bda589ee9cba93f2"><td class="memTemplParams" colspan="2"><a id="a4ab85c7f3859f871bda589ee9cba93f2" name="a4ab85c7f3859f871bda589ee9cba93f2"></a>
template&lt;typename RowIndices, typename ColIndices&gt; </td></tr>
<tr class="memitem:a4ab85c7f3859f871bda589ee9cba93f2 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1internal_1_1valid__indexed__view__overload.html">internal::valid_indexed_view_overload</a>&lt; RowIndices, ColIndices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &amp;&amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::ReturnAsIndexedView, typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const RowIndices &amp;rowIndices, const ColIndices &amp;colIndices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:ad8e40d635da86f61f1924a48eb7278e6" id="r_ad8e40d635da86f61f1924a48eb7278e6"><td class="memTemplParams" colspan="2"><a id="ad8e40d635da86f61f1924a48eb7278e6" name="ad8e40d635da86f61f1924a48eb7278e6"></a>
template&lt;typename RowIndices, typename ColIndices&gt; </td></tr>
<tr class="memitem:ad8e40d635da86f61f1924a48eb7278e6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1internal_1_1valid__indexed__view__overload.html">internal::valid_indexed_view_overload</a>&lt; RowIndices, ColIndices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &amp;&amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::ReturnAsBlock, typenameinternal::traits&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::BlockType &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const RowIndices &amp;rowIndices, const ColIndices &amp;colIndices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a8a3227d7b7bddfe6c9ed9fde74da38b4" id="r_a8a3227d7b7bddfe6c9ed9fde74da38b4"><td class="memTemplParams" colspan="2"><a id="a8a3227d7b7bddfe6c9ed9fde74da38b4" name="a8a3227d7b7bddfe6c9ed9fde74da38b4"></a>
template&lt;typename RowIndices, typename ColIndices&gt; </td></tr>
<tr class="memitem:a8a3227d7b7bddfe6c9ed9fde74da38b4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1internal_1_1valid__indexed__view__overload.html">internal::valid_indexed_view_overload</a>&lt; RowIndices, ColIndices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &amp;&amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::ReturnAsScalar, CoeffReturnType &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const RowIndices &amp;rowIndices, const ColIndices &amp;colIndices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a4ab61cfc2f0e5c32a7709cb0b0c09f31" id="r_a4ab61cfc2f0e5c32a7709cb0b0c09f31"><td class="memTemplParams" colspan="2"><a id="a4ab61cfc2f0e5c32a7709cb0b0c09f31" name="a4ab61cfc2f0e5c32a7709cb0b0c09f31"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:a4ab61cfc2f0e5c32a7709cb0b0c09f31 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &amp;&amp;(!(<a class="el" href="structEigen_1_1internal_1_1get__compile__time__incr.html">internal::get_compile_time_incr</a>&lt; typenameIvcType&lt; Indices &gt;::type &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>==1||<a class="el" href="structEigen_1_1internal_1_1is__valid__index__type.html">internal::is_valid_index_type</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>)), <a class="el" href="classEigen_1_1IndexedView.html">IndexedView</a>&lt; EIGEN_INDEXED_VIEW_METHOD_CONSTDerived, IvcIndex, typenameIvcType&lt; Indices &gt;::type &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const Indices &amp;indices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:aec81e82172e9e79194968e18b4327831" id="r_aec81e82172e9e79194968e18b4327831"><td class="memTemplParams" colspan="2"><a id="aec81e82172e9e79194968e18b4327831" name="aec81e82172e9e79194968e18b4327831"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:aec81e82172e9e79194968e18b4327831 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;(!<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>)&amp;&amp;(!(<a class="el" href="structEigen_1_1internal_1_1get__compile__time__incr.html">internal::get_compile_time_incr</a>&lt; typenameIvcType&lt; Indices &gt;::type &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>==1||<a class="el" href="structEigen_1_1internal_1_1is__valid__index__type.html">internal::is_valid_index_type</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>)), <a class="el" href="classEigen_1_1IndexedView.html">IndexedView</a>&lt; EIGEN_INDEXED_VIEW_METHOD_CONSTDerived, typenameIvcType&lt; Indices &gt;::type, IvcIndex &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const Indices &amp;indices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a540b8dbb2c4810d4c866212bb4a1df76" id="r_a540b8dbb2c4810d4c866212bb4a1df76"><td class="memTemplParams" colspan="2"><a id="a540b8dbb2c4810d4c866212bb4a1df76" name="a540b8dbb2c4810d4c866212bb4a1df76"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:a540b8dbb2c4810d4c866212bb4a1df76 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;(<a class="el" href="structEigen_1_1internal_1_1get__compile__time__incr.html">internal::get_compile_time_incr</a>&lt; typenameIvcType&lt; Indices &gt;::type &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>==1)&amp;&amp;(!<a class="el" href="structEigen_1_1internal_1_1is__valid__index__type.html">internal::is_valid_index_type</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>)&amp;&amp;(!<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>), <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a>&lt; EIGEN_INDEXED_VIEW_METHOD_CONSTDerived, <a class="el" href="structEigen_1_1internal_1_1array__size.html">internal::array_size</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const Indices &amp;indices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a69191733277414d494a7ff4f073637cb" id="r_a69191733277414d494a7ff4f073637cb"><td class="memTemplParams" colspan="2"><a id="a69191733277414d494a7ff4f073637cb" name="a69191733277414d494a7ff4f073637cb"></a>
template&lt;typename IndexType&gt; </td></tr>
<tr class="memitem:a69191733277414d494a7ff4f073637cb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; IndexType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, CoeffReturnType &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const IndexType &amp;id) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a4ab85c7f3859f871bda589ee9cba93f2" id="r_a4ab85c7f3859f871bda589ee9cba93f2"><td class="memTemplParams" colspan="2"><a id="a4ab85c7f3859f871bda589ee9cba93f2" name="a4ab85c7f3859f871bda589ee9cba93f2"></a>
template&lt;typename RowIndices, typename ColIndices&gt; </td></tr>
<tr class="memitem:a4ab85c7f3859f871bda589ee9cba93f2 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1internal_1_1valid__indexed__view__overload.html">internal::valid_indexed_view_overload</a>&lt; RowIndices, ColIndices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &amp;&amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::ReturnAsIndexedView, typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const RowIndices &amp;rowIndices, const ColIndices &amp;colIndices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:ad8e40d635da86f61f1924a48eb7278e6" id="r_ad8e40d635da86f61f1924a48eb7278e6"><td class="memTemplParams" colspan="2"><a id="ad8e40d635da86f61f1924a48eb7278e6" name="ad8e40d635da86f61f1924a48eb7278e6"></a>
template&lt;typename RowIndices, typename ColIndices&gt; </td></tr>
<tr class="memitem:ad8e40d635da86f61f1924a48eb7278e6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1internal_1_1valid__indexed__view__overload.html">internal::valid_indexed_view_overload</a>&lt; RowIndices, ColIndices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &amp;&amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::ReturnAsBlock, typenameinternal::traits&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::BlockType &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const RowIndices &amp;rowIndices, const ColIndices &amp;colIndices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a8a3227d7b7bddfe6c9ed9fde74da38b4" id="r_a8a3227d7b7bddfe6c9ed9fde74da38b4"><td class="memTemplParams" colspan="2"><a id="a8a3227d7b7bddfe6c9ed9fde74da38b4" name="a8a3227d7b7bddfe6c9ed9fde74da38b4"></a>
template&lt;typename RowIndices, typename ColIndices&gt; </td></tr>
<tr class="memitem:a8a3227d7b7bddfe6c9ed9fde74da38b4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1internal_1_1valid__indexed__view__overload.html">internal::valid_indexed_view_overload</a>&lt; RowIndices, ColIndices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &amp;&amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; typenameEIGEN_INDEXED_VIEW_METHOD_TYPE&lt; RowIndices, ColIndices &gt;::type &gt;::ReturnAsScalar, CoeffReturnType &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const RowIndices &amp;rowIndices, const ColIndices &amp;colIndices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a4ab61cfc2f0e5c32a7709cb0b0c09f31" id="r_a4ab61cfc2f0e5c32a7709cb0b0c09f31"><td class="memTemplParams" colspan="2"><a id="a4ab61cfc2f0e5c32a7709cb0b0c09f31" name="a4ab61cfc2f0e5c32a7709cb0b0c09f31"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:a4ab61cfc2f0e5c32a7709cb0b0c09f31 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a> &amp;&amp;(!(<a class="el" href="structEigen_1_1internal_1_1get__compile__time__incr.html">internal::get_compile_time_incr</a>&lt; typenameIvcType&lt; Indices &gt;::type &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>==1||<a class="el" href="structEigen_1_1internal_1_1is__valid__index__type.html">internal::is_valid_index_type</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>)), <a class="el" href="classEigen_1_1IndexedView.html">IndexedView</a>&lt; EIGEN_INDEXED_VIEW_METHOD_CONSTDerived, IvcIndex, typenameIvcType&lt; Indices &gt;::type &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const Indices &amp;indices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:aec81e82172e9e79194968e18b4327831" id="r_aec81e82172e9e79194968e18b4327831"><td class="memTemplParams" colspan="2"><a id="aec81e82172e9e79194968e18b4327831" name="aec81e82172e9e79194968e18b4327831"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:aec81e82172e9e79194968e18b4327831 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;(!<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>)&amp;&amp;(!(<a class="el" href="structEigen_1_1internal_1_1get__compile__time__incr.html">internal::get_compile_time_incr</a>&lt; typenameIvcType&lt; Indices &gt;::type &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>==1||<a class="el" href="structEigen_1_1internal_1_1is__valid__index__type.html">internal::is_valid_index_type</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>)), <a class="el" href="classEigen_1_1IndexedView.html">IndexedView</a>&lt; EIGEN_INDEXED_VIEW_METHOD_CONSTDerived, typenameIvcType&lt; Indices &gt;::type, IvcIndex &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const Indices &amp;indices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a540b8dbb2c4810d4c866212bb4a1df76" id="r_a540b8dbb2c4810d4c866212bb4a1df76"><td class="memTemplParams" colspan="2"><a id="a540b8dbb2c4810d4c866212bb4a1df76" name="a540b8dbb2c4810d4c866212bb4a1df76"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:a540b8dbb2c4810d4c866212bb4a1df76 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;(<a class="el" href="structEigen_1_1internal_1_1get__compile__time__incr.html">internal::get_compile_time_incr</a>&lt; typenameIvcType&lt; Indices &gt;::type &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>==1)&amp;&amp;(!<a class="el" href="structEigen_1_1internal_1_1is__valid__index__type.html">internal::is_valid_index_type</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>)&amp;&amp;(!<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>), <a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a>&lt; EIGEN_INDEXED_VIEW_METHOD_CONSTDerived, <a class="el" href="structEigen_1_1internal_1_1array__size.html">internal::array_size</a>&lt; Indices &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const Indices &amp;indices) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a69191733277414d494a7ff4f073637cb" id="r_a69191733277414d494a7ff4f073637cb"><td class="memTemplParams" colspan="2"><a id="a69191733277414d494a7ff4f073637cb" name="a69191733277414d494a7ff4f073637cb"></a>
template&lt;typename IndexType&gt; </td></tr>
<tr class="memitem:a69191733277414d494a7ff4f073637cb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt; <a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; IndexType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, CoeffReturnType &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const IndexType &amp;id) EIGEN_INDEXED_VIEW_METHOD_CONST</td></tr>
<tr class="memitem:a154c89b42c44e2b07923cf3ba45031aa" id="r_a154c89b42c44e2b07923cf3ba45031aa"><td class="memTemplParams" colspan="2"><a id="a154c89b42c44e2b07923cf3ba45031aa" name="a154c89b42c44e2b07923cf3ba45031aa"></a>
template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a154c89b42c44e2b07923cf3ba45031aa template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NRowsType, NColsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NColsType, NRowsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> (NRowsType nRows, NColsType nCols) EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:aa6879cb4b4e10d76f035710933d4600b" id="r_aa6879cb4b4e10d76f035710933d4600b"><td class="memTemplParams" colspan="2"><a id="aa6879cb4b4e10d76f035710933d4600b" name="aa6879cb4b4e10d76f035710933d4600b"></a>
template&lt;int Order, typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:aa6879cb4b4e10d76f035710933d4600b template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NRowsType, NColsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NColsType, NRowsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__order.html">internal::get_compiletime_reshape_order</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">Flags</a>, Order &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> (NRowsType nRows, NColsType nCols) EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:ae7be800d505dc8e3433e900528cdbc66" id="r_ae7be800d505dc8e3433e900528cdbc66"><td class="memItemLeft" align="right" valign="top"><a id="ae7be800d505dc8e3433e900528cdbc66" name="ae7be800d505dc8e3433e900528cdbc66"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> () EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:a44badf48d45a4524554a784a16678648" id="r_a44badf48d45a4524554a784a16678648"><td class="memTemplParams" colspan="2"><a id="a44badf48d45a4524554a784a16678648" name="a44badf48d45a4524554a784a16678648"></a>
template&lt;int Order&gt; </td></tr>
<tr class="memitem:a44badf48d45a4524554a784a16678648 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, 1, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__order.html">internal::get_compiletime_reshape_order</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">Flags</a>, Order &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> () EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:a154c89b42c44e2b07923cf3ba45031aa" id="r_a154c89b42c44e2b07923cf3ba45031aa"><td class="memTemplParams" colspan="2"><a id="a154c89b42c44e2b07923cf3ba45031aa" name="a154c89b42c44e2b07923cf3ba45031aa"></a>
template&lt;typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:a154c89b42c44e2b07923cf3ba45031aa template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NRowsType, NColsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NColsType, NRowsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> (NRowsType nRows, NColsType nCols) EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:aa6879cb4b4e10d76f035710933d4600b" id="r_aa6879cb4b4e10d76f035710933d4600b"><td class="memTemplParams" colspan="2"><a id="aa6879cb4b4e10d76f035710933d4600b" name="aa6879cb4b4e10d76f035710933d4600b"></a>
template&lt;int Order, typename NRowsType, typename NColsType&gt; </td></tr>
<tr class="memitem:aa6879cb4b4e10d76f035710933d4600b template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NRowsType, NColsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__size.html">internal::get_compiletime_reshape_size</a>&lt; NColsType, NRowsType, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__order.html">internal::get_compiletime_reshape_order</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">Flags</a>, Order &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> (NRowsType nRows, NColsType nCols) EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:ae7be800d505dc8e3433e900528cdbc66" id="r_ae7be800d505dc8e3433e900528cdbc66"><td class="memItemLeft" align="right" valign="top"><a id="ae7be800d505dc8e3433e900528cdbc66" name="ae7be800d505dc8e3433e900528cdbc66"></a>
EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> () EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:a44badf48d45a4524554a784a16678648" id="r_a44badf48d45a4524554a784a16678648"><td class="memTemplParams" colspan="2"><a id="a44badf48d45a4524554a784a16678648" name="a44badf48d45a4524554a784a16678648"></a>
template&lt;int Order&gt; </td></tr>
<tr class="memitem:a44badf48d45a4524554a784a16678648 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a>&lt; EIGEN_RESHAPED_METHOD_CONST Derived, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, 1, <a class="el" href="structEigen_1_1internal_1_1get__compiletime__reshape__order.html">internal::get_compiletime_reshape_order</a>&lt; <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">Flags</a>, Order &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b> () EIGEN_RESHAPED_METHOD_CONST</td></tr>
<tr class="memitem:ad69e034377b16ee5725826566977d4ed" id="r_ad69e034377b16ee5725826566977d4ed"><td class="memTemplParams" colspan="2"><a id="ad69e034377b16ee5725826566977d4ed" name="ad69e034377b16ee5725826566977d4ed"></a>
template&lt;typename Dest&gt; </td></tr>
<tr class="memitem:ad69e034377b16ee5725826566977d4ed template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><b>evalTo</b> (Dest &amp;) const</td></tr>
<tr class="memitem:aa426185ac53a24138b22fe480e89f750" id="r_aa426185ac53a24138b22fe480e89f750"><td class="memTemplParams" colspan="2"><a id="aa426185ac53a24138b22fe480e89f750" name="aa426185ac53a24138b22fe480e89f750"></a>
template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:aa426185ac53a24138b22fe480e89f750 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>lazyAssign</b> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memitem:ace7d7f3237fde5e1a5c82d36c93685be" id="r_ace7d7f3237fde5e1a5c82d36c93685be"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp&gt; </td></tr>
<tr class="memitem:ace7d7f3237fde5e1a5c82d36c93685be template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">::PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace7d7f3237fde5e1a5c82d36c93685be">NullaryExpr</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols, const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:a4aed103f49b650b70bc9f34d96068832" id="r_a4aed103f49b650b70bc9f34d96068832"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp&gt; </td></tr>
<tr class="memitem:a4aed103f49b650b70bc9f34d96068832 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">::PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aed103f49b650b70bc9f34d96068832">NullaryExpr</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size, const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:ad33c54200cc61c83ea6a9636ec31401a" id="r_ad33c54200cc61c83ea6a9636ec31401a"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp&gt; </td></tr>
<tr class="memitem:ad33c54200cc61c83ea6a9636ec31401a template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">::PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad33c54200cc61c83ea6a9636ec31401a">NullaryExpr</a> (const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:a43cb8e4cdd5908b18e50eb464dc67e3d" id="r_a43cb8e4cdd5908b18e50eb464dc67e3d"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a43cb8e4cdd5908b18e50eb464dc67e3d template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43cb8e4cdd5908b18e50eb464dc67e3d">isMuchSmallerThan</a> (const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real &amp;other, const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;prec) const</td></tr>
<tr class="memitem:a539847ae1f9922a4f22ac918f0d03b29" id="r_a539847ae1f9922a4f22ac918f0d03b29"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a539847ae1f9922a4f22ac918f0d03b29 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a539847ae1f9922a4f22ac918f0d03b29">redux</a> (const Func &amp;func) const</td></tr>
<tr class="memitem:a22095c0de728374701c582378ebdb964" id="r_a22095c0de728374701c582378ebdb964"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation&gt; </td></tr>
<tr class="memitem:a22095c0de728374701c582378ebdb964 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22095c0de728374701c582378ebdb964">minCoeff</a> () const</td></tr>
<tr class="memitem:a52381e525a33db582d2dcbbac710e1d3" id="r_a52381e525a33db582d2dcbbac710e1d3"><td class="memTemplParams" colspan="2">template&lt;int NaNPropagation&gt; </td></tr>
<tr class="memitem:a52381e525a33db582d2dcbbac710e1d3 template"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52381e525a33db582d2dcbbac710e1d3">maxCoeff</a> () const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0809dd2cb5b8f7dafcaa1083416beb8e" id="r_a0809dd2cb5b8f7dafcaa1083416beb8e"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0809dd2cb5b8f7dafcaa1083416beb8e">Constant</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a>)</td></tr>
<tr class="memitem:ad8236107f739860be6a5debeede8fdbf" id="r_ad8236107f739860be6a5debeede8fdbf"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8236107f739860be6a5debeede8fdbf">Constant</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a>)</td></tr>
<tr class="memitem:a9053c1a2e9993febe50113b05aac0f20" id="r_a9053c1a2e9993febe50113b05aac0f20"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9053c1a2e9993febe50113b05aac0f20">Constant</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">value</a>)</td></tr>
<tr class="memitem:a67114720f9034d31a7247b7534a61c9a" id="r_a67114720f9034d31a7247b7534a61c9a"><td class="memItemLeft" align="right" valign="top">EIGEN_DEPRECATED static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomAccessLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67114720f9034d31a7247b7534a61c9a">LinSpaced</a> (Sequential_t, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:a3e3568ea79f61c2eeed8ffadf341d731" id="r_a3e3568ea79f61c2eeed8ffadf341d731"><td class="memItemLeft" align="right" valign="top">EIGEN_DEPRECATED static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomAccessLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e3568ea79f61c2eeed8ffadf341d731">LinSpaced</a> (Sequential_t, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memitem:a513c7986f48517c36f992a558f81e591" id="r_a513c7986f48517c36f992a558f81e591"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomAccessLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513c7986f48517c36f992a558f81e591">LinSpaced</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:a513c7986f48517c36f992a558f81e591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <br /></td></tr>
<tr class="memitem:a1dd502457286f60df1c3e90f9192c542" id="r_a1dd502457286f60df1c3e90f9192c542"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomAccessLinSpacedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dd502457286f60df1c3e90f9192c542">LinSpaced</a> (const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:a1dd502457286f60df1c3e90f9192c542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.     <br /></td></tr>
<tr class="memitem:abc23946998f7e9b424a9690100d81505" id="r_abc23946998f7e9b424a9690100d81505"><td class="memTemplParams" colspan="2"><a id="abc23946998f7e9b424a9690100d81505" name="abc23946998f7e9b424a9690100d81505"></a>
template&lt;typename CustomNullaryOp&gt; </td></tr>
<tr class="memitem:abc23946998f7e9b424a9690100d81505 template"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NullaryExpr</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols, const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:a08224b09985b372f108850b1c605feed" id="r_a08224b09985b372f108850b1c605feed"><td class="memTemplParams" colspan="2"><a id="a08224b09985b372f108850b1c605feed" name="a08224b09985b372f108850b1c605feed"></a>
template&lt;typename CustomNullaryOp&gt; </td></tr>
<tr class="memitem:a08224b09985b372f108850b1c605feed template"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NullaryExpr</b> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size, const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:a4e0112a76ddc46846995a550da0015c9" id="r_a4e0112a76ddc46846995a550da0015c9"><td class="memTemplParams" colspan="2"><a id="a4e0112a76ddc46846995a550da0015c9" name="a4e0112a76ddc46846995a550da0015c9"></a>
template&lt;typename CustomNullaryOp&gt; </td></tr>
<tr class="memitem:a4e0112a76ddc46846995a550da0015c9 template"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NullaryExpr</b> (const CustomNullaryOp &amp;func)</td></tr>
<tr class="memitem:a3832aa9b2ee9ebdb4458003c742c9027" id="r_a3832aa9b2ee9ebdb4458003c742c9027"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3832aa9b2ee9ebdb4458003c742c9027">Zero</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols)</td></tr>
<tr class="memitem:a55794ebb0c1cba3b998063a45b18378c" id="r_a55794ebb0c1cba3b998063a45b18378c"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55794ebb0c1cba3b998063a45b18378c">Zero</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size)</td></tr>
<tr class="memitem:a8c4be762b10041d64a2b2ce85bb14ba0" id="r_a8c4be762b10041d64a2b2ce85bb14ba0"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero</a> ()</td></tr>
<tr class="memitem:adb1ce2c904a1eb3f3bab81ced1b916b6" id="r_adb1ce2c904a1eb3f3bab81ced1b916b6"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb1ce2c904a1eb3f3bab81ced1b916b6">Ones</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols)</td></tr>
<tr class="memitem:aef6ca489dc447631fe874c8071ee7edd" id="r_aef6ca489dc447631fe874c8071ee7edd"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef6ca489dc447631fe874c8071ee7edd">Ones</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size)</td></tr>
<tr class="memitem:a1284a38971d817c33e40c226f6347e37" id="r_a1284a38971d817c33e40c226f6347e37"><td class="memItemLeft" align="right" valign="top">static EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">ConstantReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1284a38971d817c33e40c226f6347e37">Ones</a> ()</td></tr>
<tr class="memitem:ae97f8d9d08f969c733c8144be6225756" id="r_ae97f8d9d08f969c733c8144be6225756"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae97f8d9d08f969c733c8144be6225756">Random</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols)</td></tr>
<tr class="memitem:a7eb5f974a8f0b67eac7080db1da0e308" id="r_a7eb5f974a8f0b67eac7080db1da0e308"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eb5f974a8f0b67eac7080db1da0e308">Random</a> (<a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size)</td></tr>
<tr class="memitem:ae814abb451b48ed872819192dc188c19" id="r_ae814abb451b48ed872819192dc188c19"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae814abb451b48ed872819192dc188c19">Random</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0dad41d83f24792e7b346fc421cb8498" id="r_a0dad41d83f24792e7b346fc421cb8498"><td class="memItemLeft" align="right" valign="top"><a id="a0dad41d83f24792e7b346fc421cb8498" name="a0dad41d83f24792e7b346fc421cb8498"></a>
EIGEN_DEPRECATED typedef <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; <a class="el" href="structEigen_1_1internal_1_1linspaced__op.html">internal::linspaced_op</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SequentialLinSpacedReturnType</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-types" class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:abe0d4bbb11be497936c00d3341bd2971" id="r_abe0d4bbb11be497936c00d3341bd2971"><td class="memItemLeft" align="right" valign="top"><a id="abe0d4bbb11be497936c00d3341bd2971" name="abe0d4bbb11be497936c00d3341bd2971"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1IndexedViewCompatibleType.html">internal::IndexedViewCompatibleType</a>&lt; <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>, 1 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>IvcIndex</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af21dc9dcff773970df6d02fb3dd72223" id="r_af21dc9dcff773970df6d02fb3dd72223"><td class="memTemplParams" colspan="2"><a id="af21dc9dcff773970df6d02fb3dd72223" name="af21dc9dcff773970df6d02fb3dd72223"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:af21dc9dcff773970df6d02fb3dd72223 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1DenseBase_1_1IvcRowType.html">IvcRowType</a>&lt; Indices &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>ivcRow</b> (const Indices &amp;indices) const</td></tr>
<tr class="memitem:a4839479dd186692195cb6e6cb87ec560" id="r_a4839479dd186692195cb6e6cb87ec560"><td class="memTemplParams" colspan="2"><a id="a4839479dd186692195cb6e6cb87ec560" name="a4839479dd186692195cb6e6cb87ec560"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:a4839479dd186692195cb6e6cb87ec560 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1DenseBase_1_1IvcColType.html">IvcColType</a>&lt; Indices &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>ivcCol</b> (const Indices &amp;indices) const</td></tr>
<tr class="memitem:a9e90605e473367e61c03d5064749d01e" id="r_a9e90605e473367e61c03d5064749d01e"><td class="memTemplParams" colspan="2"><a id="a9e90605e473367e61c03d5064749d01e" name="a9e90605e473367e61c03d5064749d01e"></a>
template&lt;typename Indices&gt; </td></tr>
<tr class="memitem:a9e90605e473367e61c03d5064749d01e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1DenseBase_1_1IvcColType.html">IvcColType</a>&lt; Indices &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>ivcSize</b> (const Indices &amp;indices) const</td></tr>
<tr class="memitem:ae966dfaa11cfd07e87da040b7a9d8216" id="r_ae966dfaa11cfd07e87da040b7a9d8216"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae966dfaa11cfd07e87da040b7a9d8216">DenseBase</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-related" class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a" id="r_a3806d3f42de165878dace160e6aba40a"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3806d3f42de165878dace160e6aba40a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;m)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Derived&gt;<br />
class Eigen::DenseBase&lt; Derived &gt;</div><p>Base class for all dense matrices, vectors, and arrays. </p>
<p>This class is the base that is inherited by all dense objects (matrix, vector, arrays, and related expression types). The common <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> API for dense objects is contained in this class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>is the derived type, e.g., a matrix type or an expression.</td></tr>
  </table>
  </dd>
</dl>
<p>This class can be extended with the help of the plugin mechanism described on the page TopicCustomizing_Plugins by defining the preprocessor symbol <code>EIGEN_DENSEBASE_PLUGIN</code>.</p>
<dl class="section see"><dt>See also</dt><dd>\blank TopicClassHierarchy </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a4dc102b445d8fb48a28dfcd22323f649" name="a4dc102b445d8fb48a28dfcd22323f649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc102b445d8fb48a28dfcd22323f649">&#9670;&#160;</a></span>InnerIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1InnerIterator.html">Eigen::InnerIterator</a>&lt;Derived&gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::InnerIterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inner iterator type to iterate over the coefficients of a row or column. </p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1InnerIterator.html" title="An InnerIterator allows to loop over the element of any matrix expression.">InnerIterator</a> </dd></dl>

</div>
</div>
<a id="a65328b7d6fc10a26ff6cd5801a6a44eb" name="a65328b7d6fc10a26ff6cd5801a6a44eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65328b7d6fc10a26ff6cd5801a6a44eb">&#9670;&#160;</a></span>PlainArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Array.html">Array</a>&lt;typename <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a> | (<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a>&amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> : <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::PlainArray</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The plain array type corresponding to this expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad871c3bef0abfc3673a6963d8201be21" title="The plain matrix or array type corresponding to this expression.">PlainObject</a> </dd></dl>

</div>
</div>
<a id="aa301ef39d63443e9ef0b84f47350116e" name="aa301ef39d63443e9ef0b84f47350116e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa301ef39d63443e9ef0b84f47350116e">&#9670;&#160;</a></span>PlainMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt;typename <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">::RowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">::ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a> | (<a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581">::Flags</a>&amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> : <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306">::MaxRowsAtCompileTime</a>, <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;<a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65">::MaxColsAtCompileTime</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::PlainMatrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The plain matrix type corresponding to this expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad871c3bef0abfc3673a6963d8201be21" title="The plain matrix or array type corresponding to this expression.">PlainObject</a> </dd></dl>

</div>
</div>
<a id="ad871c3bef0abfc3673a6963d8201be21" name="ad871c3bef0abfc3673a6963d8201be21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad871c3bef0abfc3673a6963d8201be21">&#9670;&#160;</a></span>PlainObject</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt;<a class="el" href="structEigen_1_1internal_1_1is__same.html">internal::is_same</a>&lt;typenameinternal::traits&lt;Derived&gt;::XprKind,<a class="el" href="structEigen_1_1MatrixXpr.html">MatrixXpr</a>&gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>,<a class="el" href="#aa301ef39d63443e9ef0b84f47350116e">PlainMatrix</a>,<a class="el" href="#a65328b7d6fc10a26ff6cd5801a6a44eb">PlainArray</a>&gt;::type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::PlainObject</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The plain matrix or array type corresponding to this expression. </p>
<p>This is not necessarily exactly the return type of <a class="el" href="#a5df64c66228ba75bbc66db2584185527">eval()</a>. In the case of plain matrices, the return type of <a class="el" href="#a5df64c66228ba75bbc66db2584185527">eval()</a> is a const reference to a matrix, not a matrix! It is however guaranteed that the return type of <a class="el" href="#a5df64c66228ba75bbc66db2584185527">eval()</a> is either <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21" title="The plain matrix or array type corresponding to this expression.">PlainObject</a> or const <a class="el" href="#ad871c3bef0abfc3673a6963d8201be21" title="The plain matrix or array type corresponding to this expression.">PlainObject</a>&amp;. </p>

</div>
</div>
<a id="a5feed465b3a8e60c47e73ecce83e39a2" name="a5feed465b3a8e60c47e73ecce83e39a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feed465b3a8e60c47e73ecce83e39a2">&#9670;&#160;</a></span>Scalar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;::Scalar <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Scalar</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numeric type of the expression' coefficients, e.g. float, double, int or std::complex&lt;float&gt;, etc. </p>

</div>
</div>
<a id="a2d1aba3f6c414715d830f760913c7e00" name="a2d1aba3f6c414715d830f760913c7e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1aba3f6c414715d830f760913c7e00">&#9670;&#160;</a></span>StorageIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt;Derived&gt;::StorageIndex <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::StorageIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to store indices. </p>
<p>This typedef is relevant for types that store multiple indices such as <a class="el" href="classEigen_1_1PermutationMatrix.html" title="Permutation matrix.">PermutationMatrix</a> or <a class="el" href="classEigen_1_1Transpositions.html" title="Represents a sequence of transpositions (row/column interchange)">Transpositions</a>, otherwise it defaults to <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Eigen::Index</a> </p><dl class="section see"><dt>See also</dt><dd>\blank TopicPreprocessorDirectives, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Eigen::Index</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html" title="Base class of any sparse matrices or sparse expressions.">SparseMatrixBase</a>. </dd></dl>

</div>
</div>
<a id="a9276182dab8236c33f1e7abf491d504d" name="a9276182dab8236c33f1e7abf491d504d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9276182dab8236c33f1e7abf491d504d">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numeric type of the expression' coefficients, e.g. float, double, int or std::complex&lt;float&gt;, etc.</p>
<p>It is an alias for the <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> type </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a1c5061e6cfaa937b590e2d64b78a519d" name="a1c5061e6cfaa937b590e2d64b78a519d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5061e6cfaa937b590e2d64b78a519d">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab" name="a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab"></a>RowsAtCompileTime&#160;</td><td class="fielddoc"><p>The number of rows at compile-time. This is just a copy of the value provided by the <em class="arg">Derived</em> type. If a value is not known at compile-time, it is set to the <em class="arg">Dynamic</em> constant. </p><dl class="section see"><dt>See also</dt><dd>MatrixBase::rows(), MatrixBase::cols(), <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441" name="a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441"></a>ColsAtCompileTime&#160;</td><td class="fielddoc"><p>The number of columns at compile-time. This is just a copy of the value provided by the <em class="arg">Derived</em> type. If a value is not known at compile-time, it is set to the <em class="arg">Dynamic</em> constant. </p><dl class="section see"><dt>See also</dt><dd>MatrixBase::rows(), MatrixBase::cols(), <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91" name="a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91"></a>SizeAtCompileTime&#160;</td><td class="fielddoc"><p>This is equal to the number of coefficients, i.e. the number of rows times the number of columns, or to <em class="arg">Dynamic</em> if this is not known at compile-time. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306" name="a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306"></a>MaxRowsAtCompileTime&#160;</td><td class="fielddoc"><p>This value is equal to the maximum possible number of rows that this expression might have. If this expression might have an arbitrarily high number of rows, this value is set to <em class="arg">Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dadb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65" name="a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65"></a>MaxColsAtCompileTime&#160;</td><td class="fielddoc"><p>This value is equal to the maximum possible number of columns that this expression might have. If this expression might have an arbitrarily high number of columns, this value is set to <em class="arg">Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519da3a459062d39cb34452518f5f201161d2" name="a1c5061e6cfaa937b590e2d64b78a519da3a459062d39cb34452518f5f201161d2"></a>MaxSizeAtCompileTime&#160;</td><td class="fielddoc"><p>This value is equal to the maximum possible number of coefficients that this expression might have. If this expression might have an arbitrarily high number of coefficients, this value is set to <em class="arg">Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519da25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, <a class="el" href="#a1c5061e6cfaa937b590e2d64b78a519dacc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519da1156955c8099c5072934b74c72654ed0" name="a1c5061e6cfaa937b590e2d64b78a519da1156955c8099c5072934b74c72654ed0"></a>IsVectorAtCompileTime&#160;</td><td class="fielddoc"><p>This is set to true if either the number of rows or the number of columns is known at compile-time to be equal to 1. Indeed, in that case, we are dealing with a column-vector (if there is only one column) or with a row-vector (if there is only one row). </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519da4d4548a01ba37a6c2031a3c1f0a37d34" name="a1c5061e6cfaa937b590e2d64b78a519da4d4548a01ba37a6c2031a3c1f0a37d34"></a>NumDimensions&#160;</td><td class="fielddoc"><p>This value is equal to Tensor::NumDimensions, i.e. 0 for scalars, 1 for vectors, and 2 for matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581" name="a1c5061e6cfaa937b590e2d64b78a519da7392c9b2ad41ba3c16fdc5306c04d581"></a>Flags&#160;</td><td class="fielddoc"><p>This stores expression <a class="el" href="group__flags.html">Flags</a> flags which may or may not be inherited by new expressions constructed from this one. See the <a class="el" href="group__flags.html">list of flags</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008" name="a1c5061e6cfaa937b590e2d64b78a519da406b6af91d61d348ba1c9764bdd66008"></a>IsRowMajor&#160;</td><td class="fielddoc"><p>True if this expression has row-major storage order. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae966dfaa11cfd07e87da040b7a9d8216" name="ae966dfaa11cfd07e87da040b7a9d8216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae966dfaa11cfd07e87da040b7a9d8216">&#9670;&#160;</a></span>DenseBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::DenseBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Do nothing. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a1b2641cc14a6ad2ee9703df770c096af" name="a1b2641cc14a6ad2ee9703df770c096af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2641cc14a6ad2ee9703df770c096af">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients are true</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae2fd88cfd0f2bf9cc493d0a29cbc8695">any()</a>, Cwise::operator&lt;() </dd></dl>

</div>
</div>
<a id="af1e669fd3aaae50a4870dc1b8f3b8884" name="af1e669fd3aaae50a4870dc1b8f3b8884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e669fd3aaae50a4870dc1b8f3b8884">&#9670;&#160;</a></span>allFinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::allFinite </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>*this</code> contains only finite numbers, i.e., no NaN and no +/-INF values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab13d158c900560d3e1b25d85d2d33dd6">hasNaN()</a> </dd></dl>

</div>
</div>
<a id="ae2fd88cfd0f2bf9cc493d0a29cbc8695" name="ae2fd88cfd0f2bf9cc493d0a29cbc8695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fd88cfd0f2bf9cc493d0a29cbc8695">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::any </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if at least one coefficient is true</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1b2641cc14a6ad2ee9703df770c096af">all()</a> </dd></dl>

</div>
</div>
<a id="a57591454af931f9dffa71c9da28d5641" name="a57591454af931f9dffa71c9da28d5641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57591454af931f9dffa71c9da28d5641">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::iterator <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the first element of the 1D vector or array \only_for_vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae71d079e16d91360d10066b316b48485">end()</a>, <a class="el" href="#ae9a3dfd9b826ba3103de0128576fb15b">cbegin()</a> </dd></dl>

</div>
</div>
<a id="ad9368ce70b06167ec5fc19398d329f5e" name="ad9368ce70b06167ec5fc19398d329f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9368ce70b06167ec5fc19398d329f5e">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::const_iterator <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a> </p>

</div>
</div>
<a id="a20ca095fbf288a393066b0e08a504280" name="a20ca095fbf288a393066b0e08a504280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ca095fbf288a393066b0e08a504280">&#9670;&#160;</a></span>block() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NRows, int NCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; NRows, NCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startRow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startCol</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of a block of <code>*this</code>.</dd></dl>
<p>The template parameters <em class="arg">NRows</em> and <em class="arg">NCols</em> are the number of rows and columns in the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section note"><dt>Note</dt><dd>The usage of of this overload is discouraged from Eigen 3.4, better used the generic <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, here is the one-to-one equivalence: <div class="fragment"><div class="line">mat.template <a class="code hl_function" href="#aea3e98d95cd47acce1bf5721f573ed70">block&lt;NRows,NCols&gt;</a>(i,j)  &lt;--&gt;  mat.block(i,j,fix&lt;NRows&gt;,fix&lt;NCols&gt;)</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_aea3e98d95cd47acce1bf5721f573ed70"><div class="ttname"><a href="#aea3e98d95cd47acce1bf5721f573ed70">Eigen::DenseBase::block</a></div><div class="ttdeci">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE FixedBlockXpr&lt; internal::get_fixed_value&lt; NRowsType &gt;::value, internal::get_fixed_value&lt; NColsType &gt;::value &gt;::Type block(Index startRow, Index startCol, NRowsType blockRows, NColsType blockCols)</div><div class="ttdef"><b>Definition</b> DenseBase.h:97</div></div>
</div><!-- fragment --></dd>
<dd>
since block is a templated member, the keyword template has to be used if the matrix type is also a template parameter: <div class="fragment"><div class="line">m.template <a class="code hl_function" href="#aea3e98d95cd47acce1bf5721f573ed70">block&lt;3,3&gt;</a>(1,1); </div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="adf40a0b66634af3002950c915ed15950" name="adf40a0b66634af3002950c915ed15950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf40a0b66634af3002950c915ed15950">&#9670;&#160;</a></span>block() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NRows, int NCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; NRows, NCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startRow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startCol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>blockRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>blockCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a block of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRows</td><td>number of rows in block as specified at compile-time </td></tr>
    <tr><td class="paramname">NCols</td><td>number of columns in block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block </td></tr>
    <tr><td class="paramname">blockRows</td><td>number of rows in block as specified at run-time </td></tr>
    <tr><td class="paramname">blockCols</td><td>number of columns in block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for blocks where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em class="arg">blockRows</em> should equal <em class="arg">NRows</em> unless <em class="arg">NRows</em> is <em class="arg">Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section note"><dt>Note</dt><dd>The usage of of this overload is discouraged from Eigen 3.4, better used the generic <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, here is the one-to-one complete equivalence: <div class="fragment"><div class="line">mat.template <a class="code hl_function" href="#aea3e98d95cd47acce1bf5721f573ed70">block&lt;NRows,NCols&gt;</a>(i,j,rows,cols)     &lt;--&gt;  mat.block(i,j,fix&lt;NRows&gt;(rows),fix&lt;NCols&gt;(cols))</div>
</div><!-- fragment --> If we known that, e.g., NRows==Dynamic and NCols!=Dynamic, then the equivalence becomes: <div class="fragment"><div class="line">mat.template <a class="code hl_function" href="#aea3e98d95cd47acce1bf5721f573ed70">block&lt;Dynamic,NCols&gt;</a>(i,j,rows,NCols)  &lt;--&gt;  mat.block(i,j,rows,fix&lt;NCols&gt;)</div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="aea3e98d95cd47acce1bf5721f573ed70" name="aea3e98d95cd47acce1bf5721f573ed70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3e98d95cd47acce1bf5721f573ed70">&#9670;&#160;</a></span>block() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType, typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startRow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startCol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>blockRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>blockCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a block in <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block </td></tr>
    <tr><td class="paramname">blockRows</td><td>number of rows in the block, specified at either run-time or compile-time </td></tr>
    <tr><td class="paramname">blockCols</td><td>number of columns in the block, specified at either run-time or compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>. </td></tr>
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example using runtime (aka dynamic) sizes: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>\newin{3.4}:</p>
<p>The number of rows <em class="arg">blockRows</em> and columns <em class="arg">blockCols</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. In the later case, <code>n</code> plays the role of a runtime fallback value in case <code>N</code> equals <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Eigen::Dynamic</a>. Here is an example with a fixed number of rows <code>NRows</code> and dynamic number of columns <code>cols:</code> </p><div class="fragment"><div class="line">mat.block(i,j,fix&lt;NRows&gt;,cols)</div>
</div><!-- fragment --><p>This function thus fully covers the features offered by the following overloads <a class="el" href="#a20ca095fbf288a393066b0e08a504280">block&lt;NRows,NCols&gt;(Index, Index)</a>, and <a class="el" href="#adf40a0b66634af3002950c915ed15950">block&lt;NRows,NCols&gt;(Index, Index, Index, Index)</a> that are thus obsolete. Indeed, this generic version avoids redundancy, it preserves the argument order, and prevents the need to rely on the template keyword in templated code.</p>
<p>but with less redundancy and more consistency as it does not modify the argument order and seamlessly enable hybrid fixed/dynamic sizes.</p>
<dl class="section note"><dt>Note</dt><dd>Even in the case that the returned expression has dynamic size, in the case when it is applied to a fixed-size matrix, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a>, fix, fix&lt;N&gt;(int) </dd></dl>

</div>
</div>
<a id="a9d8d812af4bbff232cbf5ff1075841b6" name="a9d8d812af4bbff232cbf5ff1075841b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8d812af4bbff232cbf5ff1075841b6">&#9670;&#160;</a></span>bottomLeftCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomLeftCorner </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size bottom-left corner of <code>*this</code>.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a40f6bc69ea4aaf31d905a1cff2fcaed2" name="a40f6bc69ea4aaf31d905a1cff2fcaed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f6bc69ea4aaf31d905a1cff2fcaed2">&#9670;&#160;</a></span>bottomLeftCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-left corner of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em class="arg">cRows</em> should equal <em class="arg">CRows</em> unless <em class="arg">CRows</em> is <em class="arg">Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="aad9b045f3effb89a9beee0e40ecbe5ba" name="aad9b045f3effb89a9beee0e40ecbe5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9b045f3effb89a9beee0e40ecbe5ba">&#9670;&#160;</a></span>bottomLeftCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType, typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-left corner of <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>. </td></tr>
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of rows <em class="arg">blockRows</em> and columns <em class="arg">blockCols</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="afe32b5faeae3a2d37248f3e7901f6f34" name="afe32b5faeae3a2d37248f3e7901f6f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe32b5faeae3a2d37248f3e7901f6f34">&#9670;&#160;</a></span>bottomRightCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomRightCorner </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size bottom-right corner of <code>*this</code>.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="adad3e30a0aa43af05c3a8eec8a46e68a" name="adad3e30a0aa43af05c3a8eec8a46e68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad3e30a0aa43af05c3a8eec8a46e68a">&#9670;&#160;</a></span>bottomRightCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-right corner of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em class="arg">cRows</em> should equal <em class="arg">CRows</em> unless <em class="arg">CRows</em> is <em class="arg">Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a19cd1740bbda13b82fb22a4a05ff3138" name="a19cd1740bbda13b82fb22a4a05ff3138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cd1740bbda13b82fb22a4a05ff3138">&#9670;&#160;</a></span>bottomRightCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType, typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-right corner of <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>. </td></tr>
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of rows <em class="arg">blockRows</em> and columns <em class="arg">blockCols</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a5bf5b481c9ee87ed68a33325f82d6c8c" name="a5bf5b481c9ee87ed68a33325f82d6c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf5b481c9ee87ed68a33325f82d6c8c">&#9670;&#160;</a></span>bottomRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the bottom rows of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a28ee74c24455d38d3248451122fa080a" name="a28ee74c24455d38d3248451122fa080a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ee74c24455d38d3248451122fa080a">&#9670;&#160;</a></span>bottomRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::bottomRows </td>
          <td>(</td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the bottom rows of <code>*this</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of rows <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a15ea9409dfdf3c0737720ab383781fda" name="a15ea9409dfdf3c0737720ab383781fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ea9409dfdf3c0737720ab383781fda">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NewType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1DenseBase_1_1CastXpr.html">CastXpr</a>&lt; NewType &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::cast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> with the <em class="arg"><a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a></em> type casted to <em class="arg">NewScalar</em>.</dd></dl>
<p>The template parameter <em class="arg">NewScalar</em> is the type we are casting the scalars to. </p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression.">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="ae9a3dfd9b826ba3103de0128576fb15b" name="ae9a3dfd9b826ba3103de0128576fb15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3dfd9b826ba3103de0128576fb15b">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::const_iterator <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a read-only const_iterator to the first element of the 1D vector or array \only_for_vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend()</a>, <a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a> </dd></dl>

</div>
</div>
<a id="aeb3b76f02986c2af2521d07164b5ffde" name="aeb3b76f02986c2af2521d07164b5ffde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3b76f02986c2af2521d07164b5ffde">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::const_iterator <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a read-only const_iterator to the element following the last element of the 1D vector or array \only_for_vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a>, <a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend()</a> </dd></dl>

</div>
</div>
<a id="ad0c05525967c16738c2cd2285b38a91f" name="ad0c05525967c16738c2cd2285b38a91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c05525967c16738c2cd2285b38a91f">&#9670;&#160;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">ColXpr</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em class="arg">i-th</em> column of <code>*this</code>. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac4c69272b7de4fae22f5f13968fb6703">row()</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="abfbb90acef01249a37f7d1323a414896" name="abfbb90acef01249a37f7d1323a414896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbb90acef01249a37f7d1323a414896">&#9670;&#160;</a></span>colwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ColwiseReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::colwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af9662cd704ffc16c5b88c7b2d331576f">rowwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, TutorialReductionsVisitorsBroadcasting </dd></dl>

</div>
</div>
<a id="a978724c07b70cb9b8fdef67a4de08788" name="a978724c07b70cb9b8fdef67a4de08788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978724c07b70cb9b8fdef67a4de08788">&#9670;&#160;</a></span>colwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1VectorwiseOp.html">ConstColwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::colwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this broadcasting and partial reductions</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#af9662cd704ffc16c5b88c7b2d331576f">rowwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, TutorialReductionsVisitorsBroadcasting </dd></dl>

</div>
</div>
<a id="a98af2017476fcc83444eea60afc4d15c" name="a98af2017476fcc83444eea60afc4d15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98af2017476fcc83444eea60afc4d15c">&#9670;&#160;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1true__type.html">ConjugateReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::conjugate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the complex conjugate of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="group__CoeffwiseMathFunctions.html#cwisetable_conj">Math functions</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a73d8782980bd75141785340d3a7a8e10">MatrixBase::adjoint()</a> </dd></dl>

</div>
</div>
<a id="a5ff2e805193f5cf5908225cd5c62a4db" name="a5ff2e805193f5cf5908225cd5c62a4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff2e805193f5cf5908225cd5c62a4db">&#9670;&#160;</a></span>conjugateIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;bool Cond&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Cond, <a class="el" href="structEigen_1_1internal_1_1true__type.html">ConjugateReturnType</a>, constDerived &amp; &gt;::type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::conjugateIf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the complex conjugate of <code>*this</code> if Cond==true, returns derived() otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a98af2017476fcc83444eea60afc4d15c">conjugate()</a> </dd></dl>

</div>
</div>
<a id="a9053c1a2e9993febe50113b05aac0f20" name="a9053c1a2e9993febe50113b05aac0f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9053c1a2e9993febe50113b05aac0f20">&#9670;&#160;</a></span>Constant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em class="arg">value</em> </dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em class="arg">CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a0809dd2cb5b8f7dafcaa1083416beb8e" name="a0809dd2cb5b8f7dafcaa1083416beb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0809dd2cb5b8f7dafcaa1083416beb8e">&#9670;&#160;</a></span>Constant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em class="arg">value</em> </dd></dl>
<p>The parameters <em class="arg">rows</em> and <em class="arg">cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em class="arg">rows</em> and <em class="arg">cols</em> as arguments, so <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> should be used instead.</p>
<p>The template parameter <em class="arg">CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="ad8236107f739860be6a5debeede8fdbf" name="ad8236107f739860be6a5debeede8fdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8236107f739860be6a5debeede8fdbf">&#9670;&#160;</a></span>Constant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em class="arg">value</em> </dd></dl>
<p>The parameter <em class="arg">size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> type.</p>
<p>\only_for_vectors</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em class="arg">size</em> as argument, so <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> should be used instead.</p>
<p>The template parameter <em class="arg">CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a87e937cc19720ffc223c9a62484d0a61" name="a87e937cc19720ffc223c9a62484d0a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e937cc19720ffc223c9a62484d0a61">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of coefficients which evaluate to true</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1b2641cc14a6ad2ee9703df770c096af">all()</a>, <a class="el" href="#ae2fd88cfd0f2bf9cc493d0a29cbc8695">any()</a> </dd></dl>

</div>
</div>
<a id="ae71d079e16d91360d10066b316b48485" name="ae71d079e16d91360d10066b316b48485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71d079e16d91360d10066b316b48485">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::iterator <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the element following the last element of the 1D vector or array \only_for_vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a57591454af931f9dffa71c9da28d5641">begin()</a>, <a class="el" href="#aeb3b76f02986c2af2521d07164b5ffde">cend()</a> </dd></dl>

</div>
</div>
<a id="ab34773522e43bfb02e9cf652d7b5dd60" name="ab34773522e43bfb02e9cf652d7b5dd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34773522e43bfb02e9cf652d7b5dd60">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::const_iterator <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="#ae71d079e16d91360d10066b316b48485">end()</a> </p>

</div>
</div>
<a id="a5df64c66228ba75bbc66db2584185527" name="a5df64c66228ba75bbc66db2584185527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df64c66228ba75bbc66db2584185527">&#9670;&#160;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EvalReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::eval </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix or vector obtained by evaluating this expression.</dd></dl>
<p>Notice that in the case of a plain matrix or vector (not an expression) this function just returns a const reference, in order to avoid a useless copy.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be careful with <a class="el" href="#a5df64c66228ba75bbc66db2584185527">eval()</a> and the auto C++ keyword, as detailed in this <a class="el" href="">page </a>. </dd></dl>

</div>
</div>
<a id="a4f5eb49e80db57f79a8353ecdf811418" name="a4f5eb49e80db57f79a8353ecdf811418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5eb49e80db57f79a8353ecdf811418">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="#a19b2bc788277e9ab3f967a8857e290ae">setConstant()</a>: sets all coefficients in this expression to <em class="arg">val</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a19b2bc788277e9ab3f967a8857e290ae">setConstant()</a>, <a class="el" href="#a0809dd2cb5b8f7dafcaa1083416beb8e">Constant()</a>, class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="ae2db4b4596edd1bf7e1c43ac2d306047" name="ae2db4b4596edd1bf7e1c43ac2d306047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2db4b4596edd1bf7e1c43ac2d306047">&#9670;&#160;</a></span>flagged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;unsigned int Added, unsigned int Removed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED const Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::flagged </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated</a></b></dt><dd>it now returns <code>*this</code> </dd></dl>

</div>
</div>
<a id="a148e20e32aa3ceca13e0a49c2cc584fc" name="a148e20e32aa3ceca13e0a49c2cc584fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148e20e32aa3ceca13e0a49c2cc584fc">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1WithFormat.html" title="Pseudo expression providing matrix output with given format.">WithFormat</a> proxy object allowing to print a matrix the with given format <em class="arg">fmt</em>.</dd></dl>
<p>See class <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">IOFormat</a> for some examples.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">IOFormat</a>, class <a class="el" href="classEigen_1_1WithFormat.html" title="Pseudo expression providing matrix output with given format.">WithFormat</a> </dd></dl>

</div>
</div>
<a id="ab13d158c900560d3e1b25d85d2d33dd6" name="ab13d158c900560d3e1b25d85d2d33dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13d158c900560d3e1b25d85d2d33dd6">&#9670;&#160;</a></span>hasNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::hasNaN </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true is <code>*this</code> contains at least one Not A Number (NaN).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af1e669fd3aaae50a4870dc1b8f3b8884">allFinite()</a> </dd></dl>

</div>
</div>
<a id="afc17b9ee8005befcf6929adf5eb0aa65" name="afc17b9ee8005befcf6929adf5eb0aa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc17b9ee8005befcf6929adf5eb0aa65">&#9670;&#160;</a></span>head() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of the first coefficients of <code>*this</code>.</dd></dl>
<p>\only_for_vectors</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a193b8eb3608c4f77a1852fe8546e364e">head(NType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a193b8eb3608c4f77a1852fe8546e364e" name="a193b8eb3608c4f77a1852fe8546e364e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193b8eb3608c4f77a1852fe8546e364e">&#9670;&#160;</a></span>head() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::head </td>
          <td>(</td>
          <td class="paramtype">NType</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the first coefficients of <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<p>\only_for_vectors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NType</td><td>the type of the value handling the number of coefficients in the segment, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of coefficients <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details.</p>
<dl class="section note"><dt>Note</dt><dd>Even in the case that the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a>, <a class="el" href="#a20ca095fbf288a393066b0e08a504280">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="ac538fdacbe2592b11174abb2049a9656" name="ac538fdacbe2592b11174abb2049a9656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac538fdacbe2592b11174abb2049a9656">&#9670;&#160;</a></span>imag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1CwiseUnaryView.html">NonConstImagReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4e7019de158be0384a19273713c74442">real()</a> </dd></dl>

</div>
</div>
<a id="acd44cafedc27a8890afb535872d930a6" name="acd44cafedc27a8890afb535872d930a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd44cafedc27a8890afb535872d930a6">&#9670;&#160;</a></span>imag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">ImagReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an read-only expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4e7019de158be0384a19273713c74442">real()</a> </dd></dl>

</div>
</div>
<a id="a02f27b90d1665656238d55e5d64e5d6f" name="a02f27b90d1665656238d55e5d64e5d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f27b90d1665656238d55e5d64e5d6f">&#9670;&#160;</a></span>innerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::innerSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension with respect to the storage order, i.e., the number of rows for a column-major matrix, and the number of columns for a row-major matrix. </dd></dl>

</div>
</div>
<a id="a11c151e4309a3ba9ab9d0e6501f7cab1" name="a11c151e4309a3ba9ab9d0e6501f7cab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c151e4309a3ba9ab9d0e6501f7cab1">&#9670;&#160;</a></span>innerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">InnerVectorReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::innerVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>outer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em class="arg">outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). </dd></dl>

</div>
</div>
<a id="a7bbdb86fa945665fe63872a5f80d058e" name="a7bbdb86fa945665fe63872a5f80d058e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbdb86fa945665fe63872a5f80d058e">&#9670;&#160;</a></span>innerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1Block.html">ConstInnerVectorReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::innerVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>outer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em class="arg">outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). Read-only. </dd></dl>

</div>
</div>
<a id="a6cc6206d125d7c10a40f80574eff93a9" name="a6cc6206d125d7c10a40f80574eff93a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc6206d125d7c10a40f80574eff93a9">&#9670;&#160;</a></span>innerVectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">InnerVectorsReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::innerVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>outerStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>outerSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em class="arg">outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). </dd></dl>

</div>
</div>
<a id="ae899184d8fe026b50169ae01287f33b3" name="ae899184d8fe026b50169ae01287f33b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae899184d8fe026b50169ae01287f33b3">&#9670;&#160;</a></span>innerVectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1Block.html">ConstInnerVectorsReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::innerVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>outerStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>outerSize</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em class="arg">outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). Read-only. </dd></dl>

</div>
</div>
<a id="af3793521d788a946cb9c5f4f92bab4d3" name="af3793521d788a946cb9c5f4f92bab4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3793521d788a946cb9c5f4f92bab4d3">&#9670;&#160;</a></span>isApprox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isApprox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> is approximately equal to <em class="arg">other</em>, within the precision determined by <em class="arg">prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. Two vectors <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v $" src="form_9.png"/></picture> and <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ w $" src="form_10.png"/></picture> are considered to be approximately equal within precision <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ p $" src="form_11.png"/></picture> if <p class="formulaDsp">
<picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ \Vert v - w \Vert \leqslant p\,\min(\Vert v\Vert, \Vert w\Vert). \]" src="form_12.png"/></picture>
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm (aka Frobenius norm L2 norm).</dd>
<dd>
Because of the multiplicativeness of this comparison, one can't use this function to check whether <code>*this</code> is approximately equal to the zero matrix or vector. Indeed, <code>isApprox(zero)</code> returns false unless <code>*this</code> itself is exactly the zero matrix or vector. If you want to test whether <code>*this</code> is zero, use internal::isMuchSmallerThan(const
RealScalar&amp;, RealScalar) instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>internal::isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a id="aafb86c9868d3d9076e01e4fc54c93e81" name="aafb86c9868d3d9076e01e4fc54c93e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb86c9868d3d9076e01e4fc54c93e81">&#9670;&#160;</a></span>isApproxToConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isApproxToConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients in this matrix are approximately equal to <em class="arg">val</em>, to within precision <em class="arg">prec</em> </dd></dl>

</div>
</div>
<a id="aba0e5df04cf80214d8298aa8dd41acbd" name="aba0e5df04cf80214d8298aa8dd41acbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0e5df04cf80214d8298aa8dd41acbd">&#9670;&#160;</a></span>isConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is just an alias for <a class="el" href="#aafb86c9868d3d9076e01e4fc54c93e81">isApproxToConstant()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients in this matrix are approximately equal to <em class="arg">value</em>, to within precision <em class="arg">prec</em> </dd></dl>

</div>
</div>
<a id="a800a25f323fc4222c822be5fdad729ac" name="a800a25f323fc4222c822be5fdad729ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800a25f323fc4222c822be5fdad729ac">&#9670;&#160;</a></span>isMuchSmallerThan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isMuchSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the norm of <code>*this</code> is much smaller than the norm of <em class="arg">other</em>, within the precision determined by <em class="arg">prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. A vector <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v $" src="form_9.png"/></picture> is considered to be much smaller than a vector <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ w $" src="form_10.png"/></picture> within precision <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ p $" src="form_11.png"/></picture> if <p class="formulaDsp">
<picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ \Vert v \Vert \leqslant p\,\Vert w\Vert. \]" src="form_15.png"/></picture>
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af3793521d788a946cb9c5f4f92bab4d3">isApprox()</a>, isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a id="a43cb8e4cdd5908b18e50eb464dc67e3d" name="a43cb8e4cdd5908b18e50eb464dc67e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cb8e4cdd5908b18e50eb464dc67e3d">&#9670;&#160;</a></span>isMuchSmallerThan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isMuchSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the norm of <code>*this</code> is much smaller than <em class="arg">other</em>, within the precision determined by <em class="arg">prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. A vector <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ v $" src="form_9.png"/></picture> is considered to be much smaller than <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ x $" src="form_13.png"/></picture> within precision <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ p $" src="form_11.png"/></picture> if <p class="formulaDsp">
<picture><source srcset="form_14_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ \Vert v \Vert \leqslant p\,\vert x\vert. \]" src="form_14.png"/></picture>
</p>
</dd></dl>
<p>For matrices, the comparison is done using the Hilbert-Schmidt norm. For this reason, the value of the reference scalar <em class="arg">other</em> should come from the Hilbert-Schmidt norm of a reference matrix of same dimensions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af3793521d788a946cb9c5f4f92bab4d3">isApprox()</a>, isMuchSmallerThan(const DenseBase&lt;OtherDerived&gt;&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a id="a91fb1c80e1fd4970a16fd509764225d7" name="a91fb1c80e1fd4970a16fd509764225d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fb1c80e1fd4970a16fd509764225d7">&#9670;&#160;</a></span>isOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isOnes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the matrix where all coefficients are equal to 1, within the precision given by <em class="arg">prec</em>.</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a1284a38971d817c33e40c226f6347e37">Ones()</a> </dd></dl>

</div>
</div>
<a id="aad9b1b1368b249e0e0f14b7f2960fb58" name="aad9b1b1368b249e0e0f14b7f2960fb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9b1b1368b249e0e0f14b7f2960fb58">&#9670;&#160;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC bool <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::isZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Product.html">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the zero matrix, within the precision given by <em class="arg">prec</em>.</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> </dd></dl>

</div>
</div>
<a id="aa394a9eeea28fee3c4624a5f9c666c7d" name="aa394a9eeea28fee3c4624a5f9c666c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa394a9eeea28fee3c4624a5f9c666c7d">&#9670;&#160;</a></span>lazyAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED EIGEN_DEVICE_FUNC Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::lazyAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="afc1420dda5e5572d29950b6a9f23ee16" name="afc1420dda5e5572d29950b6a9f23ee16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1420dda5e5572d29950b6a9f23ee16">&#9670;&#160;</a></span>leftCols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::leftCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the left columns of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a37c9f9574c5c2b6dcda11ef2adbf0f2b" name="a37c9f9574c5c2b6dcda11ef2adbf0f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c9f9574c5c2b6dcda11ef2adbf0f2b">&#9670;&#160;</a></span>leftCols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::leftCols </td>
          <td>(</td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the left columns of <code>*this</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of columns <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a1dd502457286f60df1c3e90f9192c542" name="a1dd502457286f60df1c3e90f9192c542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd502457286f60df1c3e90f9192c542">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector.    </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>\only_for_vectors</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>For integer scalar types, an even spacing is possible if and only if the length of the range, i.e., <code>high-low</code> is a scalar multiple of <code>size-1</code>, or if <code>size</code> is a scalar multiple of the number of values <code>high-low+1</code> (meaning each value can be repeated the same number of time). If one of these two considions is not satisfied, then <code>high</code> is lowered to the largest value satisfying one of this constraint. Here are some examples:</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a17a69cfd1b44b64f26b1a0f00666a871" title="Sets a linearly spaced vector.">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>    Special version for fixed size types which does not require the size parameter. </dd></dl>

</div>
</div>
<a id="a513c7986f48517c36f992a558f81e591" name="a513c7986f48517c36f992a558f81e591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513c7986f48517c36f992a558f81e591">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>\only_for_vectors</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>For integer scalar types, an even spacing is possible if and only if the length of the range, i.e., <code>high-low</code> is a scalar multiple of <code>size-1</code>, or if <code>size</code> is a scalar multiple of the number of values <code>high-low+1</code> (meaning each value can be repeated the same number of time). If one of these two considions is not satisfied, then <code>high</code> is lowered to the largest value satisfying one of this constraint. Here are some examples:</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a17a69cfd1b44b64f26b1a0f00666a871" title="Sets a linearly spaced vector.">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a3e3568ea79f61c2eeed8ffadf341d731" name="a3e3568ea79f61c2eeed8ffadf341d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3568ea79f61c2eeed8ffadf341d731">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype">Sequential_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated</a></b></dt><dd>because of accuracy loss. In <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3, it is an alias for <a class="el" href="#a1dd502457286f60df1c3e90f9192c542" title="Sets a linearly spaced vector.">LinSpaced(const Scalar&amp;,const Scalar&amp;)</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1dd502457286f60df1c3e90f9192c542" title="Sets a linearly spaced vector.">LinSpaced(const Scalar&amp;, const Scalar&amp;)</a> </dd></dl>

</div>
</div>
<a id="a67114720f9034d31a7247b7534a61c9a" name="a67114720f9034d31a7247b7534a61c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67114720f9034d31a7247b7534a61c9a">&#9670;&#160;</a></span>LinSpaced() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEPRECATED EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::LinSpaced </td>
          <td>(</td>
          <td class="paramtype">Sequential_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>because of accuracy loss. In <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3, it is an alias for <a class="el" href="#a513c7986f48517c36f992a558f81e591" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a></dd></dl>
<p>\only_for_vectors</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a513c7986f48517c36f992a558f81e591" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;, const Scalar&amp;)</a>, <a class="el" href="#a17a69cfd1b44b64f26b1a0f00666a871" title="Sets a linearly spaced vector.">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a> </dd></dl>

</div>
</div>
<a id="a52381e525a33db582d2dcbbac710e1d3" name="a52381e525a33db582d2dcbbac710e1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52381e525a33db582d2dcbbac710e1d3">&#9670;&#160;</a></span>maxCoeff() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of <code>*this</code>. In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered. </dd></dl>

</div>
</div>
<a id="a06e7d0844fbc20829bd37f2924bd2252" name="a06e7d0844fbc20829bd37f2924bd2252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e7d0844fbc20829bd37f2924bd2252">&#9670;&#160;</a></span>maxCoeff() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of *this and puts in *index its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::maxCoeff(IndexType*,IndexType*), DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::visitor(), DenseBase::maxCoeff() </dd></dl>

</div>
</div>
<a id="af3f427712ee1abba1a2fb9c1b15793d6" name="af3f427712ee1abba1a2fb9c1b15793d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f427712ee1abba1a2fb9c1b15793d6">&#9670;&#160;</a></span>maxCoeff() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>rowId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>colId</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of *this and puts in *row and *col its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), <a class="el" href="#a7f73df3954a09c7ab0dca208b6b23ddd">DenseBase::visit()</a>, DenseBase::maxCoeff() </dd></dl>

</div>
</div>
<a id="acd8b96239d3cd5e5bd4f207e86fafa11" name="acd8b96239d3cd5e5bd4f207e86fafa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8b96239d3cd5e5bd4f207e86fafa11">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::mean </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the mean of all coefficients of *this</dd></dl>
<dl class="section see"><dt>See also</dt><dd>trace(), <a class="el" href="#aba82045810e94956b893911c732fa4a8">prod()</a>, <a class="el" href="#ac7b6e2d5e05f37b6cd3f213d28fdac24">sum()</a> </dd></dl>

</div>
</div>
<a id="affbd287191d45cf87dd419e77b7d3ff9" name="affbd287191d45cf87dd419e77b7d3ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbd287191d45cf87dd419e77b7d3ff9">&#9670;&#160;</a></span>middleCols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startCol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of columns of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a79e225dc7b4e6c052a36c1bac2ce55a1" name="a79e225dc7b4e6c052a36c1bac2ce55a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e225dc7b4e6c052a36c1bac2ce55a1">&#9670;&#160;</a></span>middleCols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startCol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>numCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of columns of <code>*this</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block </td></tr>
    <tr><td class="paramname">numCols</td><td>the number of columns in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of columns <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a34a005af1e93ee45aaa3e994ddc69201" name="a34a005af1e93ee45aaa3e994ddc69201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a005af1e93ee45aaa3e994ddc69201">&#9670;&#160;</a></span>middleRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startRow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of rows of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a0c9b37290b2c800d29eb33e168a4121c" name="a0c9b37290b2c800d29eb33e168a4121c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9b37290b2c800d29eb33e168a4121c">&#9670;&#160;</a></span>middleRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>startRow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of rows of <code>*this</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of rows in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of rows <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a22095c0de728374701c582378ebdb964" name="a22095c0de728374701c582378ebdb964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22095c0de728374701c582378ebdb964">&#9670;&#160;</a></span>minCoeff() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of <code>*this</code>. In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is minimum of elements that are not NaN </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered. </dd></dl>

</div>
</div>
<a id="a5ac4a70f0e577e12fb5b41645b5d98ac" name="a5ac4a70f0e577e12fb5b41645b5d98ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac4a70f0e577e12fb5b41645b5d98ac">&#9670;&#160;</a></span>minCoeff() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of *this and puts in *index its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::maxCoeff(IndexType*,IndexType*), <a class="el" href="#a7f73df3954a09c7ab0dca208b6b23ddd">DenseBase::visit()</a>, DenseBase::minCoeff() </dd></dl>

</div>
</div>
<a id="a4ca170ba37a8def95cca1965aecce1d1" name="a4ca170ba37a8def95cca1965aecce1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca170ba37a8def95cca1965aecce1d1">&#9670;&#160;</a></span>minCoeff() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NaNPropagation, typename IndexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>rowId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *</td>          <td class="paramname"><span class="paramname"><em>colId</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of *this and puts in *row and *col its location.</dd></dl>
<p>In case <code>*this</code> contains NaN, NaNPropagation determines the behavior: NaNPropagation == PropagateFast : undefined NaNPropagation == PropagateNaN : result is NaN NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN </p><dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::minCoeff(Index*), DenseBase::maxCoeff(Index*,Index*), <a class="el" href="#a7f73df3954a09c7ab0dca208b6b23ddd">DenseBase::visit()</a>, DenseBase::minCoeff() </dd></dl>

</div>
</div>
<a id="aa031d4cb63530f9e0a1627fd0408fdcb" name="aa031d4cb63530f9e0a1627fd0408fdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa031d4cb63530f9e0a1627fd0408fdcb">&#9670;&#160;</a></span>nestByValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::nestByValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the temporary version of *this. </dd></dl>

</div>
</div>
<a id="a64ca9fffefedd184e634f8cf087f6588" name="a64ca9fffefedd184e634f8cf087f6588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ca9fffefedd184e634f8cf087f6588">&#9670;&#160;</a></span>nonZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of nonzero coefficients which is in practice the number of stored coefficients. </dd></dl>

</div>
</div>
<a id="ad33c54200cc61c83ea6a9636ec31401a" name="ad33c54200cc61c83ea6a9636ec31401a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33c54200cc61c83ea6a9636ec31401a">&#9670;&#160;</a></span>NullaryExpr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomNullaryOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">::PlainObject</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::NullaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomNullaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em class="arg">func</em> </dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays.">DenseBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em class="arg">CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="ace7d7f3237fde5e1a5c82d36c93685be" name="ace7d7f3237fde5e1a5c82d36c93685be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7d7f3237fde5e1a5c82d36c93685be">&#9670;&#160;</a></span>NullaryExpr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomNullaryOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">::PlainObject</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::NullaryExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em class="arg">func</em> </dd></dl>
<p>The parameters <em class="arg">rows</em> and <em class="arg">cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em class="arg">rows</em> and <em class="arg">cols</em> as arguments, so <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> should be used instead.</p>
<p>The template parameter <em class="arg">CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a4aed103f49b650b70bc9f34d96068832" name="a4aed103f49b650b70bc9f34d96068832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aed103f49b650b70bc9f34d96068832">&#9670;&#160;</a></span>NullaryExpr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomNullaryOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;<a class="el" href="#ad871c3bef0abfc3673a6963d8201be21">::PlainObject</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::NullaryExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em class="arg">func</em> </dd></dl>
<p>The parameter <em class="arg">size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>\only_for_vectors</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em class="arg">size</em> as argument, so <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> should be used instead.</p>
<p>The template parameter <em class="arg">CustomNullaryOp</em> is the type of the functor.</p>
<p>Here is an example with C++11 random generators: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a1284a38971d817c33e40c226f6347e37" name="a1284a38971d817c33e40c226f6347e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1284a38971d817c33e40c226f6347e37">&#9670;&#160;</a></span>Ones() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Ones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size matrix or vector where all coefficients equal one.</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aef6ca489dc447631fe874c8071ee7edd">Ones(Index)</a>, <a class="el" href="#adb1ce2c904a1eb3f3bab81ced1b916b6">Ones(Index,Index)</a>, <a class="el" href="#a91fb1c80e1fd4970a16fd509764225d7">isOnes()</a>, class <a class="el" href="#adb1ce2c904a1eb3f3bab81ced1b916b6">Ones</a> </dd></dl>

</div>
</div>
<a id="adb1ce2c904a1eb3f3bab81ced1b916b6" name="adb1ce2c904a1eb3f3bab81ced1b916b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1ce2c904a1eb3f3bab81ced1b916b6">&#9670;&#160;</a></span>Ones() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix where all coefficients equal one.</dd></dl>
<p>The parameters <em class="arg">rows</em> and <em class="arg">cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em class="arg">rows</em> and <em class="arg">cols</em> as arguments, so <a class="el" href="#a1284a38971d817c33e40c226f6347e37">Ones()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1284a38971d817c33e40c226f6347e37">Ones()</a>, <a class="el" href="#aef6ca489dc447631fe874c8071ee7edd">Ones(Index)</a>, <a class="el" href="#a91fb1c80e1fd4970a16fd509764225d7">isOnes()</a>, class <a class="el" href="#adb1ce2c904a1eb3f3bab81ced1b916b6">Ones</a> </dd></dl>

</div>
</div>
<a id="aef6ca489dc447631fe874c8071ee7edd" name="aef6ca489dc447631fe874c8071ee7edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6ca489dc447631fe874c8071ee7edd">&#9670;&#160;</a></span>Ones() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a vector where all coefficients equal one.</dd></dl>
<p>The parameter <em class="arg">newSize</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>\only_for_vectors</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em class="arg">size</em> as argument, so <a class="el" href="#a1284a38971d817c33e40c226f6347e37">Ones()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1284a38971d817c33e40c226f6347e37">Ones()</a>, <a class="el" href="#adb1ce2c904a1eb3f3bab81ced1b916b6">Ones(Index,Index)</a>, <a class="el" href="#a91fb1c80e1fd4970a16fd509764225d7">isOnes()</a>, class <a class="el" href="#adb1ce2c904a1eb3f3bab81ced1b916b6">Ones</a> </dd></dl>

</div>
</div>
<a id="ae441c0556de0ce7d41812b52777ef3f4" name="ae441c0556de0ce7d41812b52777ef3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae441c0556de0ce7d41812b52777ef3f4">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NegativeReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the opposite of <code>*this</code> </dd></dl>

</div>
</div>
<a id="ad0054eb99270d11e4b2f57ade70f0c1d" name="ad0054eb99270d11e4b2f57ade70f0c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0054eb99270d11e4b2f57ade70f0c1d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae55fbfa5630cabf2a9cba1248581bc66">operator&lt;&lt;(const Scalar&amp;)</a> </dd></dl>

</div>
</div>
<a id="ae55fbfa5630cabf2a9cba1248581bc66" name="ae55fbfa5630cabf2a9cba1248581bc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55fbfa5630cabf2a9cba1248581bc66">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="anchor" id="MatrixBaseCommaInitRef"></a>Convenient operator to set the coefficients of a matrix.</p>
<p>The coefficients must be provided in a row major order and exactly match the size of the matrix. Otherwise an assertion is raised.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section note"><dt>Note</dt><dd>According the c++ standard, the argument expressions of this comma initializer are evaluated in arbitrary order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structEigen_1_1CommaInitializer.html#a87dd22a8aa63222a264d263a254255b1">CommaInitializer::finished()</a>, class <a class="el" href="structEigen_1_1CommaInitializer.html" title="Helper class used by the comma initializer operator.">CommaInitializer</a> </dd></dl>

</div>
</div>
<a id="aae79d5d0d95e60bf2e64d0dc3dfd66a4" name="aae79d5d0d95e60bf2e64d0dc3dfd66a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae79d5d0d95e60bf2e64d0dc3dfd66a4">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special case of the template operator=, in order to prevent the compiler from generating a default operator= (issue hit with g++ 4.1) </p>

</div>
</div>
<a id="a581a7a353bd007b5352f11688e3bc5fa" name="a581a7a353bd007b5352f11688e3bc5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581a7a353bd007b5352f11688e3bc5fa">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <em class="arg">other</em> into *this. </p><dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a6462697d5a6fa3104f5f1213fdf9ff12" name="a6462697d5a6fa3104f5f1213fdf9ff12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6462697d5a6fa3104f5f1213fdf9ff12">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the generic expression <em class="arg">other</em> into *this. </p>
<p>The expression must provide a (templated) evalTo(Derived&amp; dst) const function which does the actual job. In practice, this allows any user to write its own special matrix without having to modify <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a></p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a1e002168ce504d56d923e54463ae6553" name="a1e002168ce504d56d923e54463ae6553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e002168ce504d56d923e54463ae6553">&#9670;&#160;</a></span>outerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::outerSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the outer size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a vector, this returns just 1. For a matrix (non-vector), this is the major dimension with respect to the storage order, i.e., the number of columns for a column-major matrix, and the number of rows for a row-major matrix. </dd></dl>

</div>
</div>
<a id="aba82045810e94956b893911c732fa4a8" name="aba82045810e94956b893911c732fa4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba82045810e94956b893911c732fa4a8">&#9670;&#160;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::prod </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the product of all coefficients of *this</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac7b6e2d5e05f37b6cd3f213d28fdac24">sum()</a>, <a class="el" href="#acd8b96239d3cd5e5bd4f207e86fafa11">mean()</a>, trace() </dd></dl>

</div>
</div>
<a id="ae814abb451b48ed872819192dc188c19" name="ae814abb451b48ed872819192dc188c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814abb451b48ed872819192dc188c19">&#9670;&#160;</a></span>Random() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Random </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size random matrix or vector expression</dd></dl>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<p>\not_reentrant</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a39046dff78acbcb389ad0b018e587c8e">DenseBase::setRandom()</a>, <a class="el" href="#ae97f8d9d08f969c733c8144be6225756">DenseBase::Random(Index,Index)</a>, <a class="el" href="#a7eb5f974a8f0b67eac7080db1da0e308">DenseBase::Random(Index)</a> </dd></dl>

</div>
</div>
<a id="ae97f8d9d08f969c733c8144be6225756" name="ae97f8d9d08f969c733c8144be6225756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97f8d9d08f969c733c8144be6225756">&#9670;&#160;</a></span>Random() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a random matrix expression</dd></dl>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<p>The parameters <em class="arg">rows</em> and <em class="arg">cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>\not_reentrant</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em class="arg">rows</em> and <em class="arg">cols</em> as arguments, so <a class="el" href="#ae814abb451b48ed872819192dc188c19">Random()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<p>See <a class="el" href="#a4aed103f49b650b70bc9f34d96068832">DenseBase::NullaryExpr(Index, const CustomNullaryOp&amp;)</a> for an example using C++11 random generators.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a39046dff78acbcb389ad0b018e587c8e">DenseBase::setRandom()</a>, <a class="el" href="#a7eb5f974a8f0b67eac7080db1da0e308">DenseBase::Random(Index)</a>, <a class="el" href="#ae814abb451b48ed872819192dc188c19">DenseBase::Random()</a> </dd></dl>

</div>
</div>
<a id="a7eb5f974a8f0b67eac7080db1da0e308" name="a7eb5f974a8f0b67eac7080db1da0e308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb5f974a8f0b67eac7080db1da0e308">&#9670;&#160;</a></span>Random() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a random vector expression</dd></dl>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<p>The parameter <em class="arg">size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>\only_for_vectors \not_reentrant</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em class="arg">size</em> as argument, so <a class="el" href="#ae814abb451b48ed872819192dc188c19">Random()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary vector whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a39046dff78acbcb389ad0b018e587c8e">DenseBase::setRandom()</a>, <a class="el" href="#ae97f8d9d08f969c733c8144be6225756">DenseBase::Random(Index,Index)</a>, <a class="el" href="#ae814abb451b48ed872819192dc188c19">DenseBase::Random()</a> </dd></dl>

</div>
</div>
<a id="a4e7019de158be0384a19273713c74442" name="a4e7019de158be0384a19273713c74442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7019de158be0384a19273713c74442">&#9670;&#160;</a></span>real() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1true__type.html">NonConstRealReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac538fdacbe2592b11174abb2049a9656">imag()</a> </dd></dl>

</div>
</div>
<a id="a655dc0515df0e0d487ed9ed9b39430e8" name="a655dc0515df0e0d487ed9ed9b39430e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655dc0515df0e0d487ed9ed9b39430e8">&#9670;&#160;</a></span>real() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="structEigen_1_1internal_1_1true__type.html">RealReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac538fdacbe2592b11174abb2049a9656">imag()</a> </dd></dl>

</div>
</div>
<a id="a539847ae1f9922a4f22ac918f0d03b29" name="a539847ae1f9922a4f22ac918f0d03b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539847ae1f9922a4f22ac918f0d03b29">&#9670;&#160;</a></span>redux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::redux </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the result of a full redux operation on the whole matrix or vector using <em class="arg">func</em> </dd></dl>
<p>The template parameter <em class="arg">BinaryOp</em> is the type of the functor <em class="arg">func</em> which must be an associative operator. Both current C++98 and C++11 functor styles are handled.</p>
<dl class="section warning"><dt>Warning</dt><dd>the matrix must be not empty, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac7b6e2d5e05f37b6cd3f213d28fdac24">DenseBase::sum()</a>, DenseBase::minCoeff(), DenseBase::maxCoeff(), <a class="el" href="#abfbb90acef01249a37f7d1323a414896">MatrixBase::colwise()</a>, <a class="el" href="#ac1fbfd5b45f2b4b9bff9d1994e335863">MatrixBase::rowwise()</a> </dd></dl>

</div>
</div>
<a id="ae36c50ce9e9d49a2b7a32ef54da5540c" name="ae36c50ce9e9d49a2b7a32ef54da5540c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36c50ce9e9d49a2b7a32ef54da5540c">&#9670;&#160;</a></span>replicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int RowFactor, int ColFactor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, RowFactor, ColFactor &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::replicate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a73fc08418d4fada0221cf6f96dbf30d0">VectorwiseOp::replicate()</a>, DenseBase::replicate(Index,Index), class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="af9b5c151029f975956791322c5b7b919" name="af9b5c151029f975956791322c5b7b919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b5c151029f975956791322c5b7b919">&#9670;&#160;</a></span>replicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rowFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>colFactor</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a73fc08418d4fada0221cf6f96dbf30d0">VectorwiseOp::replicate()</a>, <a class="el" href="#ae36c50ce9e9d49a2b7a32ef54da5540c">DenseBase::replicate&lt;int,int&gt;()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="a13027a493a68a13496610caf3d81bd3e" name="a13027a493a68a13496610caf3d81bd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13027a493a68a13496610caf3d81bd3e">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are <a class="el" href="classEigen_1_1PlainObjectBase.html#a99d9054ee2d5a40c6e00ded0265e9cea">Matrix::resize()</a> and <a class="el" href="classEigen_1_1PlainObjectBase.html#a99d9054ee2d5a40c6e00ded0265e9cea">Array::resize()</a>. The present method only asserts that the new size equals the old size, and does nothing else. </p>

</div>
</div>
<a id="aef40c2ee48a85a799270c8258cc12b76" name="aef40c2ee48a85a799270c8258cc12b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef40c2ee48a85a799270c8258cc12b76">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are <a class="el" href="classEigen_1_1PlainObjectBase.html#a99d9054ee2d5a40c6e00ded0265e9cea">Matrix::resize()</a> and <a class="el" href="classEigen_1_1PlainObjectBase.html#a99d9054ee2d5a40c6e00ded0265e9cea">Array::resize()</a>. The present method only asserts that the new size equals the old size, and does nothing else. </p>

</div>
</div>
<a id="acde1eef3a99bbbb4ac694ca55b1764c8" name="acde1eef3a99bbbb4ac694ca55b1764c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde1eef3a99bbbb4ac694ca55b1764c8">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ReverseReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the reverse of *this.</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> 
</div>
</div>
<a id="ada2ea028e35de0beef990fa0f6e3dee1" name="ada2ea028e35de0beef990fa0f6e3dee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2ea028e35de0beef990fa0f6e3dee1">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="#acde1eef3a99bbbb4ac694ca55b1764c8">reverse()</a>. </p>

</div>
</div>
<a id="a11014cd4565501e332bdd38c0028f736" name="a11014cd4565501e332bdd38c0028f736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11014cd4565501e332bdd38c0028f736">&#9670;&#160;</a></span>reverseInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::reverseInPlace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of reverse: it reverses <code>*this</code>.</p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional benefits:</p><ul>
<li>less error prone: doing the same operation with .<a class="el" href="#acde1eef3a99bbbb4ac694ca55b1764c8">reverse()</a> requires special care: <div class="fragment"><div class="line">m = m.reverse().eval(); </div>
</div><!-- fragment --></li>
<li>this API enables reverse operations without the need for a temporary</li>
<li>it allows future optimizations (cache friendliness, etc.)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a2bd419527acce58e9e813a5af654b81c">VectorwiseOp::reverseInPlace()</a>, <a class="el" href="#acde1eef3a99bbbb4ac694ca55b1764c8">reverse()</a> </dd></dl>

</div>
</div>
<a id="af5e466f472f91afd86925c68925525f7" name="af5e466f472f91afd86925c68925525f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e466f472f91afd86925c68925525f7">&#9670;&#160;</a></span>rightCols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::rightCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the right columns of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a6835fcaaf239e3e5ed2fd12e6d41566d" name="a6835fcaaf239e3e5ed2fd12e6d41566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6835fcaaf239e3e5ed2fd12e6d41566d">&#9670;&#160;</a></span>rightCols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NColsBlockXpr.html">NColsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::rightCols </td>
          <td>(</td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the right columns of <code>*this</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of columns <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="ac4c69272b7de4fae22f5f13968fb6703" name="ac4c69272b7de4fae22f5f13968fb6703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c69272b7de4fae22f5f13968fb6703">&#9670;&#160;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1Block.html">RowXpr</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em class="arg">i-th</em> row of <code>*this</code>. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad0c05525967c16738c2cd2285b38a91f">col()</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="ac1fbfd5b45f2b4b9bff9d1994e335863" name="ac1fbfd5b45f2b4b9bff9d1994e335863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fbfd5b45f2b4b9bff9d1994e335863">&#9670;&#160;</a></span>rowwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RowwiseReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::rowwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a978724c07b70cb9b8fdef67a4de08788">colwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, TutorialReductionsVisitorsBroadcasting </dd></dl>

</div>
</div>
<a id="af9662cd704ffc16c5b88c7b2d331576f" name="af9662cd704ffc16c5b88c7b2d331576f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9662cd704ffc16c5b88c7b2d331576f">&#9670;&#160;</a></span>rowwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1VectorwiseOp.html">ConstRowwiseReturnType</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::rowwise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a> wrapper of *this for broadcasting and partial reductions</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a978724c07b70cb9b8fdef67a4de08788">colwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, TutorialReductionsVisitorsBroadcasting </dd></dl>

</div>
</div>
<a id="a2b3627ef4c1ce521e46f439ea393f445" name="a2b3627ef4c1ce521e46f439ea393f445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3627ef4c1ce521e46f439ea393f445">&#9670;&#160;</a></span>segment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of a segment (i.e. a vector block) in <code>*this</code> </dd></dl>
<p>\only_for_vectors</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the index of the first element in the segment </td></tr>
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at compile-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab4bf41770a8db6522d472d05c7cbced8">segment(Index,NType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="ab4bf41770a8db6522d472d05c7cbced8" name="ab4bf41770a8db6522d472d05c7cbced8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bf41770a8db6522d472d05c7cbced8">&#9670;&#160;</a></span>segment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NType</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a segment (i.e. a vector block) in <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<p>\only_for_vectors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the first coefficient in the segment </td></tr>
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NType</td><td>the type of the value handling the number of coefficients in the segment, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of coefficients <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details.</p>
<dl class="section note"><dt>Note</dt><dd>Even in the case that the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, fix&lt;N&gt;, fix&lt;N&gt;(int), class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a4b481a88facffd21b91754fba205607d" name="a4b481a88facffd21b91754fba205607d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b481a88facffd21b91754fba205607d">&#9670;&#160;</a></span>select() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename ThenDerived, typename ElseDerived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, ElseDerived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thenMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elseMatrix</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a matrix where each coefficient (i,j) is equal to <em class="arg">thenMatrix(i,j)</em> if <code>*this</code>(i,j), and <em class="arg">elseMatrix(i,j)</em> otherwise.</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?:">Select</a> </dd></dl>

</div>
</div>
<a id="ae808c307d84c5a7a4e444edc409fdd44" name="ae808c307d84c5a7a4e444edc409fdd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae808c307d84c5a7a4e444edc409fdd44">&#9670;&#160;</a></span>select() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename ThenDerived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, typename ThenDerived::ConstantReturnType &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>thenMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ThenDerived::Scalar &amp;</td>          <td class="paramname"><span class="paramname"><em>elseScalar</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>else</em> expression being a scalar value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4b481a88facffd21b91754fba205607d">DenseBase::select(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const</a>, class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?:">Select</a> </dd></dl>

</div>
</div>
<a id="a5a3f75f1adaca52f8064d914d15af2af" name="a5a3f75f1adaca52f8064d914d15af2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3f75f1adaca52f8064d914d15af2af">&#9670;&#160;</a></span>select() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename ElseDerived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, typename ElseDerived::ConstantReturnType, ElseDerived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const typename ElseDerived::Scalar &amp;</td>          <td class="paramname"><span class="paramname"><em>thenScalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elseMatrix</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>then</em> expression being a scalar value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4b481a88facffd21b91754fba205607d">DenseBase::select(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const</a>, class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?:">Select</a> </dd></dl>

</div>
</div>
<a id="a19b2bc788277e9ab3f967a8857e290ae" name="a19b2bc788277e9ab3f967a8857e290ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b2bc788277e9ab3f967a8857e290ae">&#9670;&#160;</a></span>setConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to value <em class="arg">val</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f5eb49e80db57f79a8353ecdf811418">fill()</a>, setConstant(Index,const Scalar&amp;), setConstant(Index,Index,const Scalar&amp;), <a class="el" href="#ac74411ddeea2545bf20baf14613be47e">setZero()</a>, <a class="el" href="#ad18970fd7d9f9c3d8db9d05fa8652a25">setOnes()</a>, <a class="el" href="#a0809dd2cb5b8f7dafcaa1083416beb8e">Constant()</a>, class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#ac74411ddeea2545bf20baf14613be47e">setZero()</a>, <a class="el" href="#ad18970fd7d9f9c3d8db9d05fa8652a25">setOnes()</a> </dd></dl>

</div>
</div>
<a id="a99dd31774d69545aba5d4f598cd27c4b" name="a99dd31774d69545aba5d4f598cd27c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dd31774d69545aba5d4f598cd27c4b">&#9670;&#160;</a></span>setLinSpaced() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setLinSpaced </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector. </p>
<p>The function fills <code>*this</code> with equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>\only_for_vectors</p>
<p>For integer scalar types, do not miss the explanations on the definition of <a class="el" href="#a513c7986f48517c36f992a558f81e591">even spacing </a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a513c7986f48517c36f992a558f81e591" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="#a17a69cfd1b44b64f26b1a0f00666a871" title="Sets a linearly spaced vector.">setLinSpaced(Index, const Scalar&amp;, const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="a17a69cfd1b44b64f26b1a0f00666a871" name="a17a69cfd1b44b64f26b1a0f00666a871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a69cfd1b44b64f26b1a0f00666a871">&#9670;&#160;</a></span>setLinSpaced() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setLinSpaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>newSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a linearly spaced vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>\only_for_vectors</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>For integer scalar types, do not miss the explanations on the definition of <a class="el" href="#a513c7986f48517c36f992a558f81e591">even spacing </a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a513c7986f48517c36f992a558f81e591" title="Sets a linearly spaced vector.">LinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a id="ad18970fd7d9f9c3d8db9d05fa8652a25" name="ad18970fd7d9f9c3d8db9d05fa8652a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18970fd7d9f9c3d8db9d05fa8652a25">&#9670;&#160;</a></span>setOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setOnes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to one.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a1284a38971d817c33e40c226f6347e37">Ones()</a> </dd></dl>

</div>
</div>
<a id="a39046dff78acbcb389ad0b018e587c8e" name="a39046dff78acbcb389ad0b018e587c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39046dff78acbcb389ad0b018e587c8e">&#9670;&#160;</a></span>setRandom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setRandom </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to random values.</p>
<p>Numbers are uniformly spread through their whole definition range for integer types, and in the [-1:1] range for floating point scalar types.</p>
<p>\not_reentrant</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, setRandom(Index), setRandom(Index,Index) </dd></dl>

</div>
</div>
<a id="ac74411ddeea2545bf20baf14613be47e" name="ac74411ddeea2545bf20baf14613be47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74411ddeea2545bf20baf14613be47e">&#9670;&#160;</a></span>setZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::setZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to zero.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor.">CwiseNullaryOp</a>, <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> </dd></dl>

</div>
</div>
<a id="aa9ae074fb95265bf28eae0570950cc23" name="aa9ae074fb95265bf28eae0570950cc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ae074fb95265bf28eae0570950cc23">&#9670;&#160;</a></span>subVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Direction==<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>, <a class="el" href="classEigen_1_1Block.html">ColXpr</a>, <a class="el" href="classEigen_1_1Block.html">RowXpr</a> &gt;::type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::subVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the i-th subvector (column or vector) according to the <code>Direction</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a949d26e45aa6df9e2d2abd4e184193cc">subVectors()</a> </dd></dl>

</div>
</div>
<a id="a06e44b4dd3c95433bf22f144fa9d08ba" name="a06e44b4dd3c95433bf22f144fa9d08ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e44b4dd3c95433bf22f144fa9d08ba">&#9670;&#160;</a></span>subVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1conditional.html">internal::conditional</a>&lt; Direction==<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>, <a class="el" href="classEigen_1_1Block.html">ConstColXpr</a>, <a class="el" href="classEigen_1_1Block.html">ConstRowXpr</a> &gt;::type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::subVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="#aa9ae074fb95265bf28eae0570950cc23">subVector(Index)</a> </p>

</div>
</div>
<a id="a949d26e45aa6df9e2d2abd4e184193cc" name="a949d26e45aa6df9e2d2abd4e184193cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949d26e45aa6df9e2d2abd4e184193cc">&#9670;&#160;</a></span>subVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::subVectors </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of subvectors (rows or columns) in the direction <code>Direction</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa9ae074fb95265bf28eae0570950cc23">subVector(Index)</a> </dd></dl>

</div>
</div>
<a id="ac7b6e2d5e05f37b6cd3f213d28fdac24" name="ac7b6e2d5e05f37b6cd3f213d28fdac24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b6e2d5e05f37b6cd3f213d28fdac24">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;<a class="el" href="#a5feed465b3a8e60c47e73ecce83e39a2">::Scalar</a> <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::sum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of all coefficients of <code>*this</code> </dd></dl>
<p>If <code>*this</code> is empty, then the value 0 is returned.</p>
<dl class="section see"><dt>See also</dt><dd>trace(), <a class="el" href="#aba82045810e94956b893911c732fa4a8">prod()</a>, <a class="el" href="#acd8b96239d3cd5e5bd4f207e86fafa11">mean()</a> </dd></dl>

</div>
</div>
<a id="a40aa938e7e7fecafb3178ef37dc977ec" name="a40aa938e7e7fecafb3178ef37dc977ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aa938e7e7fecafb3178ef37dc977ec">&#9670;&#160;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swaps *this with the expression <em class="arg">other</em>. </p>

</div>
</div>
<a id="a23524b632b0dab3e3fa52378ef863f77" name="a23524b632b0dab3e3fa52378ef863f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23524b632b0dab3e3fa52378ef863f77">&#9670;&#160;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swaps *this with the matrix or array <em class="arg">other</em>. </p>

</div>
</div>
<a id="a08564a0fb59f2ba7eee05bd539a07135" name="a08564a0fb59f2ba7eee05bd539a07135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08564a0fb59f2ba7eee05bd539a07135">&#9670;&#160;</a></span>tail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of the last coefficients of <code>*this</code>.</dd></dl>
<p>\only_for_vectors</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac2b0d76db0790618c5ac2c4dbb723d18">tail(NType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="ac2b0d76db0790618c5ac2c4dbb723d18" name="ac2b0d76db0790618c5ac2c4dbb723d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b0d76db0790618c5ac2c4dbb723d18">&#9670;&#160;</a></span>tail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedSegmentReturnType.html">FixedSegmentReturnType</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::tail </td>
          <td>(</td>
          <td class="paramtype">NType</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a last coefficients of <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<p>\only_for_vectors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NType</td><td>the type of the value handling the number of coefficients in the segment, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of coefficients <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details.</p>
<dl class="section note"><dt>Note</dt><dd>Even in the case that the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a>, <a class="el" href="#a20ca095fbf288a393066b0e08a504280">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a1ecceaddc1f9f721934e92d8fa457238" name="a1ecceaddc1f9f721934e92d8fa457238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecceaddc1f9f721934e92d8fa457238">&#9670;&#160;</a></span>topLeftCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topLeftCorner </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size top-left corner of <code>*this</code>.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a0458abf04c04cbb12c65aa7270c6be0c" name="a0458abf04c04cbb12c65aa7270c6be0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0458abf04c04cbb12c65aa7270c6be0c">&#9670;&#160;</a></span>topLeftCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a top-left corner of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em class="arg">cRows</em> should equal <em class="arg">CRows</em> unless <em class="arg">CRows</em> is <em class="arg">Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a19c05b545831778f587c26236e0eefa3" name="a19c05b545831778f587c26236e0eefa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c05b545831778f587c26236e0eefa3">&#9670;&#160;</a></span>topLeftCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType, typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topLeftCorner </td>
          <td>(</td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a top-left corner of <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>. </td></tr>
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of rows <em class="arg">blockRows</em> and columns <em class="arg">blockCols</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="a46522717e54d3178d053d11832eb5b9a" name="a46522717e54d3178d053d11832eb5b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46522717e54d3178d053d11832eb5b9a">&#9670;&#160;</a></span>topRightCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topRightCorner </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size top-right corner of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">CCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a>, <a class="el" href="#a20ca095fbf288a393066b0e08a504280">block&lt;int,int&gt;(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="aa568d28749715cd0363778c843bd1770" name="aa568d28749715cd0363778c843bd1770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa568d28749715cd0363778c843bd1770">&#9670;&#160;</a></span>topRightCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; CRows, CCols &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a top-right corner of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em class="arg">cRows</em> should equal <em class="arg">CRows</em> unless <em class="arg">CRows</em> is <em class="arg">Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="aeaca1c01dde5d29db181a2661b48807d" name="aeaca1c01dde5d29db181a2661b48807d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaca1c01dde5d29db181a2661b48807d">&#9670;&#160;</a></span>topRightCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType, typename NColsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1FixedBlockXpr.html">FixedBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a>, <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NColsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topRightCorner </td>
          <td>(</td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>cRows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NColsType</td>          <td class="paramname"><span class="paramname"><em>cCols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a expression of a top-right corner of <code>*this</code> with either dynamic or fixed sizes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>. </td></tr>
    <tr><td class="paramname">NColsType</td><td>the type of the value handling the number of columns in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example with dynamic sizes: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of rows <em class="arg">blockRows</em> and columns <em class="arg">blockCols</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="aee644f2f7050a8fbc7e5873d6d6df236" name="aee644f2f7050a8fbc7e5873d6d6df236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee644f2f7050a8fbc7e5873d6d6df236">&#9670;&#160;</a></span>topRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; N &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">N</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the top rows of <code>*this</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em class="arg">n</em> should equal <em class="arg">N</em> unless <em class="arg">N</em> is <em class="arg">Dynamic</em>.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="aee7e190ad2aa5567b5e4497f1e5ea137" name="aee7e190ad2aa5567b5e4497f1e5ea137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7e190ad2aa5567b5e4497f1e5ea137">&#9670;&#160;</a></span>topRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NRowsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="structEigen_1_1DenseBase_1_1NRowsBlockXpr.html">NRowsBlockXpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1get__fixed__value.html">internal::get_fixed_value</a>&lt; NRowsType &gt;<a class="el" href="#a8da735a6bfc7012606acf787156d10a0">::value</a> &gt;::Type <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::topRows </td>
          <td>(</td>
          <td class="paramtype">NRowsType</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the top rows of <code>*this</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRowsType</td><td>the type of the value handling the number of rows in the block, typically <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Index</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The number of rows <em class="arg">n</em> can also be specified at compile-time by passing Eigen::fix&lt;N&gt;, or Eigen::fix&lt;N&gt;(n) as arguments. See <a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block() </a> for the details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea3e98d95cd47acce1bf5721f573ed70">block(Index,Index,NRowsType,NColsType)</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> </dd></dl>

</div>
</div>
<a id="acdada00d813939c0c9e90db5c01585c8" name="acdada00d813939c0c9e90db5c01585c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdada00d813939c0c9e90db5c01585c8">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::TransposeReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the transpose of *this.</dd></dl>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its own transpose, do <b>NOT</b> do this: <div class="fragment"><div class="line">m = m.transpose(); <span class="comment">// bug!!! caused by aliasing effect</span></div>
</div><!-- fragment --> Instead, use the <a class="el" href="#a2bf1856f4ff79f0db0e6d416a2edfb0f">transposeInPlace()</a> method: <div class="fragment"><div class="line">m.transposeInPlace();</div>
</div><!-- fragment --> which gives <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> good opportunities for optimization, or alternatively you can also do: <div class="fragment"><div class="line">m = m.transpose().eval();</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2bf1856f4ff79f0db0e6d416a2edfb0f">transposeInPlace()</a>, adjoint() </dd></dl>

</div>
</div>
<a id="aeedbef96d04a73342f6f62ec1a1c46e3" name="aeedbef96d04a73342f6f62ec1a1c46e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedbef96d04a73342f6f62ec1a1c46e3">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstTransposeReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="#acdada00d813939c0c9e90db5c01585c8">transpose()</a>.</p>
<p>Make sure you read the warning for <a class="el" href="#acdada00d813939c0c9e90db5c01585c8">transpose()</a> !</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2bf1856f4ff79f0db0e6d416a2edfb0f">transposeInPlace()</a>, adjoint() </dd></dl>

</div>
</div>
<a id="a2bf1856f4ff79f0db0e6d416a2edfb0f" name="a2bf1856f4ff79f0db0e6d416a2edfb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf1856f4ff79f0db0e6d416a2edfb0f">&#9670;&#160;</a></span>transposeInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::transposeInPlace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of <a class="el" href="#acdada00d813939c0c9e90db5c01585c8">transpose()</a>: it replaces <code>*this</code> by its own transpose. Thus, doing </p><div class="fragment"><div class="line">m.transposeInPlace();</div>
</div><!-- fragment --><p> has the same effect on m as doing </p><div class="fragment"><div class="line">m = m.transpose().eval();</div>
</div><!-- fragment --><p> and is faster and also safer because in the latter line of code, forgetting the <a class="el" href="#a5df64c66228ba75bbc66db2584185527">eval()</a> results in a bug caused by aliasing.</p>
<p>Notice however that this method is only useful if you want to replace a matrix by its own transpose. If you just need the transpose of a matrix, use <a class="el" href="#acdada00d813939c0c9e90db5c01585c8">transpose()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>if the matrix is not square, then <code>*this</code> must be a resizable matrix. This excludes (non-square) fixed-size matrices, block-expressions and maps.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acdada00d813939c0c9e90db5c01585c8">transpose()</a>, adjoint(), adjointInPlace() </dd></dl>

</div>
</div>
<a id="a18bb16e6a73979ef9a348c82472bfb15" name="a18bb16e6a73979ef9a348c82472bfb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bb16e6a73979ef9a348c82472bfb15">&#9670;&#160;</a></span>unaryExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomUnaryOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt; CustomUnaryOp, const Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::unaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomUnaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CustomUnaryOp()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a unary operator coefficient-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor implementing the unary operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CustomUnaryOp</td><td>Type of <em class="arg">func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An expression of a custom coefficient-wise unary operator <em class="arg">func</em> of *this</dd></dl>
<p>The function <code>ptr_fun()</code> from the C++ standard library can be used to make functors out of normal functions.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>Genuine functors allow for more possibilities, for instance it may contain a state.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6332da04d6616c32f59259c4d70416ef">unaryViewExpr</a>, binaryExpr, class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression.">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="a6332da04d6616c32f59259c4d70416ef" name="a6332da04d6616c32f59259c4d70416ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6332da04d6616c32f59259c4d70416ef">&#9670;&#160;</a></span>unaryViewExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomViewOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt; CustomViewOp, const Derived &gt; <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::unaryViewExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomViewOp &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CustomViewOp()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise unary operator <em class="arg">func</em> of *this</dd></dl>
<p>The template parameter <em class="arg">CustomUnaryOp</em> is the type of the functor of the custom unary operator.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a18bb16e6a73979ef9a348c82472bfb15" title="Apply a unary operator coefficient-wise.">unaryExpr</a>, binaryExpr class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression.">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="a8da735a6bfc7012606acf787156d10a0" name="a8da735a6bfc7012606acf787156d10a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da735a6bfc7012606acf787156d10a0">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC CoeffReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the unique coefficient of a 1x1 expression </dd></dl>

</div>
</div>
<a id="a7f73df3954a09c7ab0dca208b6b23ddd" name="a7f73df3954a09c7ab0dca208b6b23ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f73df3954a09c7ab0dca208b6b23ddd">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename Visitor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC void <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;</td>          <td class="paramname"><span class="paramname"><em>visitor</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the visitor <em class="arg">visitor</em> to the whole coefficients of the matrix or vector.</p>
<p>The template parameter <em class="arg">Visitor</em> is the type of the visitor and provides the following interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVisitor {</div>
<div class="line">  <span class="comment">// called for the first coefficient</span></div>
<div class="line">  <span class="keywordtype">void</span> init(<span class="keyword">const</span> <a class="code hl_typedef" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; <a class="code hl_function" href="#a8da735a6bfc7012606acf787156d10a0">value</a>, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> j);</div>
<div class="line">  <span class="comment">// called for all other coefficients</span></div>
<div class="line">  <span class="keywordtype">void</span> operator() (<span class="keyword">const</span> <a class="code hl_typedef" href="#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; <a class="code hl_function" href="#a8da735a6bfc7012606acf787156d10a0">value</a>, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i, <a class="code hl_typedef" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> j);</div>
<div class="line">};</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a5feed465b3a8e60c47e73ecce83e39a2"><div class="ttname"><a href="#a5feed465b3a8e60c47e73ecce83e39a2">Eigen::DenseBase::Scalar</a></div><div class="ttdeci">internal::traits&lt; Derived &gt;::Scalar Scalar</div><div class="ttdef"><b>Definition</b> DenseBase.h:66</div></div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a8da735a6bfc7012606acf787156d10a0"><div class="ttname"><a href="#a8da735a6bfc7012606acf787156d10a0">Eigen::DenseBase::value</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC CoeffReturnType value() const</div><div class="ttdef"><b>Definition</b> DenseBase.h:526</div></div>
<div class="ttc" id="anamespaceEigen_html_a62e77e0933482dafde8fe197d9a2cfde"><div class="ttname"><a href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a></div><div class="ttdeci">EIGEN_DEFAULT_DENSE_INDEX_TYPE Index</div><div class="ttdoc">The Index type as used for the API.</div><div class="ttdef"><b>Definition</b> Meta.h:74</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>compared to one or two <em>for</em> <em>loops</em>, visitors offer automatic unrolling for small fixed size matrix.</dd>
<dd>
if the matrix is empty, then the visitor is left unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>minCoeff(Index*,Index*), maxCoeff(Index*,Index*), DenseBase::redux() </dd></dl>

</div>
</div>
<a id="a8c4be762b10041d64a2b2ce85bb14ba0" name="a8c4be762b10041d64a2b2ce85bb14ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4be762b10041d64a2b2ce85bb14ba0">&#9670;&#160;</a></span>Zero() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Zero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size zero matrix or vector.</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a55794ebb0c1cba3b998063a45b18378c">Zero(Index)</a>, <a class="el" href="#a3832aa9b2ee9ebdb4458003c742c9027">Zero(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a3832aa9b2ee9ebdb4458003c742c9027" name="a3832aa9b2ee9ebdb4458003c742c9027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3832aa9b2ee9ebdb4458003c742c9027">&#9670;&#160;</a></span>Zero() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a zero matrix.</dd></dl>
<p>The parameters <em class="arg">rows</em> and <em class="arg">cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em class="arg">rows</em> and <em class="arg">cols</em> as arguments, so <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a>, <a class="el" href="#a55794ebb0c1cba3b998063a45b18378c">Zero(Index)</a> </dd></dl>

</div>
</div>
<a id="a55794ebb0c1cba3b998063a45b18378c" name="a55794ebb0c1cba3b998063a45b18378c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55794ebb0c1cba3b998063a45b18378c">&#9670;&#160;</a></span>Zero() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase</a>&lt; Derived &gt;::Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a zero vector.</dd></dl>
<p>The parameter <em class="arg">size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> type.</p>
<p>\only_for_vectors</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em class="arg">size</em> as argument, so <a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"></div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8c4be762b10041d64a2b2ce85bb14ba0">Zero()</a>, <a class="el" href="#a3832aa9b2ee9ebdb4458003c742c9027">Zero(Index,Index)</a> </dd></dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a3806d3f42de165878dace160e6aba40a" name="a3806d3f42de165878dace160e6aba40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3806d3f42de165878dace160e6aba40a">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outputs the matrix, to the given stream.</p>
<p>If you wish to print the matrix with a format different than the default, use <a class="el" href="#a148e20e32aa3ceca13e0a49c2cc584fc">DenseBase::format()</a>.</p>
<p>It is also possible to change the default format by defining EIGEN_DEFAULT_IO_FORMAT before including <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> headers. If not defined, this will automatically be defined to <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">Eigen::IOFormat()</a>, that is the <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed.">Eigen::IOFormat</a> with default parameters.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a148e20e32aa3ceca13e0a49c2cc584fc">DenseBase::format()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="DenseBase_8h_source.html">DenseBase.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Assign_8h_source.html">Assign.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="BooleanRedux_8h_source.html">BooleanRedux.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="CommaInitializer_8h_source.html">CommaInitializer.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="CwiseNullaryOp_8h_source.html">CwiseNullaryOp.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="EigenBase_8h_source.html">EigenBase.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Fuzzy_8h_source.html">Fuzzy.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="IO_8h_source.html">IO.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="NestByValue_8h_source.html">NestByValue.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Random_8h_source.html">Random.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Redux_8h_source.html">Redux.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Replicate_8h_source.html">Replicate.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="ReturnByValue_8h_source.html">ReturnByValue.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Reverse_8h_source.html">Reverse.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Select_8h_source.html">Select.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="SelfCwiseBinaryOp_8h_source.html">SelfCwiseBinaryOp.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="StlIterators_8h_source.html">StlIterators.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Transpose_8h_source.html">Transpose.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="VectorwiseOp_8h_source.html">VectorwiseOp.h</a></li>
<li>nuli-avionics-flight-software/platformio_nuli_avionics_flight_software/include/Eigen/src/Core/<a class="el" href="Visitor_8h_source.html">Visitor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
